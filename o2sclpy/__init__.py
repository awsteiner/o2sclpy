#  -------------------------------------------------------------------
#  
#  Copyright (C) 2006-2019, Andrew W. Steiner
#  
#  This file is part of O2sclpy.
#  
#  O2sclpy is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#  
#  O2sclpy is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with O2sclpy. If not, see <http://www.gnu.org/licenses/>.
#  
#  -------------------------------------------------------------------
#
# O2sclpy is a library of classes and functions which integrates
# O2scl, python, and matplotlib. The principal purpose of the library
# is to provide a script named 'o2graph', which allows fast analysis
# and plotting of HDF5 files (especially those generated by O2scl).

# Current state of yt integration:
# 
# Created parameters  yt_axis_color, yt_axis_labels_flat (t/f)
# yt_resolution [x,y], yt_focus, yt_position, yt_path
# Created new blank functions yt-add-vol (for tensor_grid), yt-path,
# yt-render, yt-scatter (for table)
#
# Next things to do:
# 1) The yt-tf mechanism is ok, but we need to figure out
#    how to distinguish between absolute and arbitrary values
#    for tf limits
# 2) Figure out how to implement transfer functions
# 3) Create yt-surface

import sys
import h5py
import math
import os

# For MD5 hashes
import hashlib

import matplotlib.pyplot as plot

# For rectangles
import matplotlib.patches as patches
# To create new color maps
from matplotlib.colors import LinearSegmentedColormap
# For build_o2scl(), link_o2scl() and download_file()
import urllib.request

import numpy
import ctypes
import readline

# For wrapping help text
import textwrap

# For system type detection in build_o2scl() and link_o2scl()
import platform

# For code.interact() in 'python' command
import code 

# For slack notify
import json
import requests
import socket

cmaps=[('Perceptually Uniform Sequential',
        ['viridis','plasma','inferno','magma']),
       ('Sequential', 
        ['Greys','Purples','Blues','Greens','Oranges','Reds',
         'YlOrBr','YlOrRd','OrRd','PuRd','RdPu','BuPu',
         'GnBu','PuBu','YlGnBu','PuBuGn','BuGn','YlGn']),
       ('Sequential (2)', 
        ['binary','gist_yarg','gist_gray','gray','bone','pink',
         'spring','summer','autumn','winter','cool','Wistia',
         'hot','afmhot','gist_heat','copper']),
       ('Diverging', 
        ['PiYG','PRGn','BrBG','PuOr','RdGy','RdBu',
         'RdYlBu','RdYlGn','Spectral','coolwarm','bwr','seismic']),
       ('Qualitative', 
        ['Pastel1','Pastel2','Paired','Accent',
         'Dark2','Set1','Set2','Set3',
         'tab10','tab20','tab20b','tab20c']),
       ('Miscellaneous', 
        ['flag','prism','ocean','gist_earth','terrain','gist_stern',
         'gnuplot','gnuplot2','CMRmap','cubehelix','brg','hsv',
         'gist_rainbow','rainbow','jet','nipy_spectral','gist_ncar'])]
"""
List of cmaps for 'help cmaps'
"""

new_cmaps=[('O2sclpy cmaps',
            ['jet2','pastel2','reds2','greens2','blues2'])]
"""
List of new o2sclpy cmaps
"""

version='0.923.2'
"""
The version number string
"""

base_list=[
    ["arrow","Plot an arrow.",
     "<x1> <y1> <x2> <y2> <arrow properties> [kwargs]",
     "Plot an arrow from (x1,y1) to (x2,y2). This command uses "+
     "axes.annotate() to generate an arrow with an empty string "+
     "as the first argument to annotate(). The o2graph argument <arrow "+
     "properties> is the python dictionary for the 'arrowprops' "+
     "argument to annotate(). The arrowstyle and connectionstyle "+
     "attributes should be listed along with other arrowprops attributes.\n"+
     " \nExamples for arrowprops are:\n"+
     "\"arrowstyle=->,connectionstyle=arc3\"\n"+
     "\"arrowstyle=-|>,connectionstyle=arc,fc=red,ec=blue\"\n"+
     "\"arrowstyle=-|>,connectionstyle=arc,head_length=4.0,"+
     "head_width=1.0\"\n"+
     "\"arrowstyle=->,connectionstyle=arc3,head_length=4.0,"+
     "head_width=1.0,rad=-0.1\"\n"+
     "\"arrowstyle=fancy,connectionstyle=arc3,head_length=4.0,"+
     "head_width=1.0,rad=-0.1\"\n \n"+
     "Summary for arrowstyle argument (angleB is renamed to as_angleB):\n"+
     "Name    Attributes\n"+
     "-       None\n"+
     "->      head_length=0.4,head_width=0.2\n"+
     "-[      widthB=1.0,lengthB=0.2,as_angleB=None\n"+
     "|-      widthA=1.0,widthB=1.0\n"+
     "-|      head_length=0.4,head_width=0.2\n"+
     "<-      head_length=0.4,head_width=0.2\n"+
     "<-      head_length=0.4,head_width=0.2\n"+
     "<|      head_length=0.4,head_width=0.2\n"+
     "<|      head_length=0.4,head_width=0.2\n"+
     "fancy   head_length=0.4,head_width=0.4,tail_width=0.4\n"+
     "simple  head_length=0.5,head_width=0.5,tail_width=0.2\n"+
     "wedge   tail_width=0.3,shrink_factor=0.5\n \n"+
     "(note that fancy, simple or wedge require arc3 or angle3 connection "+
     "styles)\n \n"+
     "Summary for connectionstyle argument (angleB is renamed to "+
     "cs_angleB):\n"+
     "Name    Attributes\n"+
     "angle   angleA=90,cs_angleB=0,rad=0.0\n"+
     "angle3  angleA=90,cs_angleB=0\n"+
     "arc     angleA=0,cs_angleB=0,armA=None,armB=None,rad=0.0\n"+
     "arc3    rad=0.0\n"+
     "bar     armA=0.0,armB=0.0,fraction=0.3,angle=None\n \n"+
     "See https://matplotlib.org/2.0.2/users/annotations.html for more."],
    ["backend","Select the matplotlib backend to use.","<backend>",
     "This selects the matplotlib backend. "+
     "Typical values are 'Agg', 'TkAgg', 'WX', 'QTAgg', 'QT4Agg'. "+
     "Use -backend Agg to save the plot to a file without "+
     "opening a window. The backend can only be changed once, i.e. "+
     "if the \"backend\" command is invoked "+
     "more than once, then only the last invocation will have any "+
     "effect."],
    ["canvas","Create a plotting canvas.","",
     "Create an empty plotting canvas. For example 'o2graph "+
     "-canvas -show'."],
    ["clf","Clear the current figure.","",
     "Clear the current figure."],
    ["eval","Run the python eval() function.","<source code>",
     "Long desc."],
    ["line","Plot a line.","<x1> <y1> <x2> <y2> [kwargs]",
     "Plot a line from (x1,y1) to (xy,y2). Some useful "+
     "kwargs are color (c), dashes, linestyle (ls), linewidth (lw), "+
     "marker, markeredgecolor (mec), markeredgewidth (mew), "+
     "markerfacecolor (mfc), markerfacecoloralt (mfcalt), markersize "+
     "(ms). For example: o2graph -line 0.05 0.05 0.95 0.95 "+
     "lw=0,marker='+' -show"],
    ["move-labels","Move the labels.","",""],
    ["new-cmaps","Define new color maps.","",
     "Define new color maps, 'jet2', 'pastel2' "+
     "'reds2', 'greens2', and 'blues2'."],
    ["plotv","Plot several vector-like data sets.",
     "[multiple vector spec. for x] <multiple vector spec. for y>",
     "The 'plotv' command plots one or several pairs of vectors for x "+
     "and y. The total number of curves plotted will be the number "+
     "of vector data sets from the first argument times the number "+
     "of vector data sets from the second argument. If the x and y "+
     "vector lengths are not equal, then the longer vector is "+
     "truncated. Any kwargs are applied to all curves plotted. For "+
     "details on multiple vector specifications, use "+
     "'o2graph -help mult-vector-spec'. Note that 'plotv' uses "+
     "the vector<contour_line> object as temporary storage, so if "+
     "the current object has type vector<contour_line> then you "+
     "will need to save that object to a file and use 'clear' first."],
    ["point","Plot a single point.","",""],
    ["python","Begin an interactive python session.","",""],
    ["rect","Plot a rectangle.",
     "<x1> <y1> <x2> <y2> <angle> [kwargs]",
     "Plot a rectange from (x1,y1) to (xy,y2) with "+
     "rotation angle <angle>. By default, the rectangle has no border, "+
     "but the linewidth ('lw') and edgecolor kwargs can be used to "+
     "specify one if desired."],
    ["reset-xlim","Reset the x-axis limits.","",
     "This is an alias for 'set xset False', and indicates "+
     "that the values of 'xlo' and 'xhi' are to be ignored until the "+
     "next call to 'xlimits'."],
    ["reset-ylim","Reset the y-axis limits.","",
     "This is an alias for 'set yset False', and indicates "+
     "that the values of 'ylo' and 'yhi' are to be ignored until the "+
     "next call to 'ylimits'."],
    ["reset-zlim","Reset the z-azis limits.","",
     "This is an alias for 'set zset False', and indicates "+
     "that the values of 'zlo' and 'zhi' are to be ignored until the "+
     "next call to 'zlimits'."],
    ["save","Save the current plot in a file.","<filename>",
     "Save the current plot in a file similar "+
     "to plot.savefig(). The action of this command depends on "+
     "which backend was selected. File type depends on the "+
     "extension, typically either .png, .pdf, .eps, .jpg, .raw, .svg, "+
     "and .tif ."],
    ["show","Show the current plot.","","Show the current plot "+
     "on the screen and begin "+
     "the graphical user interface. This is similar to plot.show()."],
    ["text","Plot text in the data coordinates.",
     "<x> <y> <text> [kwargs]","The 'text' command plots text in the "+
     "data coordinates defined by the current axes with the font size "+
     "determined by the value of the parameter 'font'."],
    ["textbox",
     "Plot a box with text.","<x1> <y1> <text> <bbox properties> [kwargs]",
     "Plot text <text> and a box at location <x1> <y1>. For example, "+
     "textbox 0.5 0.5 \"$ f(x) $\" \"alpha=0.8,facecolor=white\" ."],
    ["ttext","Plot text in window coordinates [(0,0) to (1,1)].",
     "<x> <y> <text> [kwargs]","The 'text' command plots text in the "+
     "window coordinates [typically (0,0) to (1,1)] with the font size "+
     "determined by the value of the parameter 'font'."],
    ["xlimits","Set the x-axis limits.","<low> <high>",
     "Set 'xlo' and 'xhi' to the specified limits, "+
     "and set 'xset' to true. If a plotting canvas is currently "+
     "open, then "+
     "the x-limits on that plot are modified. Future plots are also "+
     "set with the specified x-limits."],
    ["ylimits","Set the y-axis limits.","<low> <high>",
     "Set 'ylo' and 'yhi' to the specified limits, "+
     "and set 'yset' to true. If a plotting canvas is currently "+
     "open, then "+
     "the y-limits on that plot are modified. Future plots are also "+
     "set with the specified y-limits."],
    ["yt-path","Set yt animation path.","",
     "Long desc."],
    ["yt-render","Render the yt visualization.",
     "<filename pattern>","Long desc."],
    ["zlimits","Set the z-azis limits.","<low> <high>",
     "Set 'zlo' and 'zhi' to the specified limits, "+
     "and set 'zset' to true. If a plotting canvas is currently "+
     "open, then "+
     "the z-limits on that plot are modified. Future plots are also "+
     "set with the specified z-limits."],
    ["yt-tf","Edit the yt transfer function.","","Long desc."],
    ["subplots","Create subplots.","<nrows> <ncols> [kwargs]",
     "Create a grid of <nrows> by <ncols> subplots. "+
     "The kwargs currently supported are 'sharex', 'sharey', "+
     "and 'squeeze'."],
    ["selsub","Select subplot.","1D: <row or col> 2D: <row> <col>",
     "Select which subplot to use for subsequent plotting commands. "+
     "If there is only one row, then 'selsub' needs only the column "+
     "arugment, and if there is only one column, then 'selsub' needs "+
     "only the row argument. Otherwise, two arguments are needed to "+
     "specify the row and column. The rows and columns begin with "+
     "zero and start in the upper left."],
    ["xtitle","Add x title to plot (or subplot).","",""],
    ["ytitle","Add y title to plot (or subplot).","",""],
    ["subadj","Adjust subplots.","<kwargs>",
     "The kwargs for 'subadj' are left, right, bottom, top, "+
     "wspace, and hspace."]
]
"""
This is a list of 4-element entries:
1: command name
2: short description
3: argument list
4: full help text
"""

# Types which appear in extra_list below (not a list of all acol types)
extra_types=["table","table3d","hist_2d","hist","double[]","int[]",
             "size_t[]","tensor","tensor<int>","tensor<size_t>",
             "tensor_grid"]
"""
List of types which have additional plotting commands
"""

extra_list=[
    ["table","plot",
     "Plot two columns from the table.",
     "<x> <y> [kwargs]",
     "If the current object is a table, then plot "+
     "column <y> versus column "+
     "<x>. If the current object is a one-dimensional histogram, then plot "+
     "the histogram weights as a function of the bin representative values. "+
     "If the current object is a set of contour lines, then plot the full "+
     "set of contour lines. Some useful kwargs are color (c), dashes, "+
     "linestyle (ls), linewidth (lw), marker, markeredgecolor (mec), "+
     "markeredgewidth (mew), markerfacecolor (mfc), markerfacecoloralt "+
     "(mfcalt), markersize (ms). For example: o2graph -create x 0 10 0.2 "+
     "-function sin(x) y -plot x y lw=0,marker='+' -show"],
    ["table","rplot",
     "Plot a region inside a column or in between two columns.",
     "<x1> <y1> [x2 y2] [kwargs]",
     "If either 2 or 3 arguments are specified, "+
     "this command plots the "+
     "region inside the curve defined by the specified set of x and y "+
     "values. The first point is copied at the end to ensure a closed "+
     "region. If 4 or 5 arguments are specified, then this command plots the "+
     "region in between two sets of x and y values, again adding the first "+
     "point from (x1,y1) to the end to ensure a closed region."],
    ["table","scatter","Create a scatter plot from 2-4 columns.",
     "<x> <y> [s] [c] [kwargs]",
     "This command creates a scatter plot form "+
     "columns <x> and <y>, "+
     "optionally using column [s] to choose the marker size and optionally "+
     "using column [c] to choose the marker color. To vary the marker colors "+
     "while choosing the default marker size just specify 'None' as the "+
     "argument for [s]. Or, to specify keyword arguments while using the "+
     "default size and color, specify 'None' as the argument for both [s] "+
     "and [c]."],
    ["table","errorbar",
     "Plot the specified columns with errobars.",
     "<x> <y> <xerr> <yerr> [kwargs]",
     "Plot column <y> versus column <x> with "+
     "symmetric error bars given in "+
     "column <xerr> and <yerr>. For no uncertainty in either the x or y "+
     "direction, just use 0 for <xerr> or <yerr>, respectively. New kwargs "+
     "for the errorbar command are ecolor=None, elinewidth=None, "+
     "capsize=None, barsabove=False, lolims=False, uplims=False, "+
     "xlolims=False, xuplims=False, errorevery=1, capthick=None, hold=None"],
    ["table","yt-scatter","Add scattered points to a yt scene",
     "<x column> <y column> <z column> [color column] [size column]",
     "Long desc."],
    ["table","plot1","Plot the specified column.","<y> [kwargs]",
     "Plot column <y> versus row number. Some "+
     "useful kwargs are color (c), "+
     "dashes, linestyle (ls), linewidth (lw), marker, markeredgecolor (mec), "+
     "markeredgewidth (mew), markerfacecolor (mfc), markerfacecoloralt "+
     "(mfcalt), markersize (ms). For example: o2 -create x 0 10 0.2 "+
     "-function sin(x) y -plot1 y ls='--',marker='o' -show"],
    ["table","histplot","Create a histogram plot from column in a table.",
     "<col>","For a table, create a histogram plot from the "+
     "specified column. This command uses matplotlib to construct the "+
     "histogram rather than using O2scl to create a hist_2d object."],
    ["table","hist2dplot",
     "Create a 2-D histogram plot from two columns in a table.",
     "<col x> <col y>","For a table, create a 2D histogram plot from "+
     "the specified columns. This command uses matplotlib to construct the "+
     "histogram rather than using O2scl to create a hist object."],
    ["table3d","den-plot","Create a density plot from a table3d object.",
     "<slice>",
     "Creates a density plot from the specified "+
     "slice. Logarithmic x- or "+
     "y-axes are handled by taking the base 10 log of the x- or y-grids "+
     "specified in the table3d object before plotting. A z-axis density "+
     "legend is print on the RHS if colbar is set to True before plotting. If "+
     "z-axis limits are specified, then values larger than the upper limit "+
     "are set equal to the upper limit and values smaller than the lower "+
     "limit are set equal to the lower limit before plotting."],
    ["hist","plot","Plot the histogram.","[kwargs]",
     "Plot the histogram weights as a function "+
     "of the bin representative values. "+
     "Some useful kwargs (which apply for all three object types) are "+
     "color (c), dashes, linestyle (ls), linewidth (lw), marker, "+
     "markeredgecolor (mec), markeredgewidth (mew), markerfacecolor (mfc), "+
     "markerfacecoloralt (mfcalt), markersize (ms). For example: o2graph "+
     "-create x 0 10 0.2 -function sin(x) y "+
     "-plot x y lw=0,marker='+' -show"],
    ["double[]","plot1","Plot the array.","[kwargs]",
     "Plot the array. Some useful kwargs "+
     "are color (c), dashes, linestyle (ls), linewidth (lw), marker, "+
     "markeredgecolor (mec), markeredgewidth (mew), markerfacecolor (mfc), "+
     "markerfacecoloralt (mfcalt), markersize (ms)."],
    ["int[]","plot1","Plot the array.","[kwargs]",
     "Plot the array. Some useful kwargs "+
     "are color (c), dashes, linestyle (ls), linewidth (lw), marker, "+
     "markeredgecolor (mec), markeredgewidth (mew), markerfacecolor (mfc), "+
     "markerfacecoloralt (mfcalt), markersize (ms)."],
    ["size_t[]","plot1","Plot the array.","[kwargs]",
     "Plot the array. Some useful kwargs "+
     "are color (c), dashes, linestyle (ls), linewidth (lw), marker, "+
     "markeredgecolor (mec), markeredgewidth (mew), markerfacecolor (mfc), "+
     "markerfacecoloralt (mfcalt), markersize (ms)."],
    ["vector<contour_line>","plot","Plot the contour lines.","[kwargs]",
     "Plot the set of contour lines. Some "+
     "useful kwargs (which apply for all three "+
     "object types) are color (c), dashes, linestyle (ls), linewidth (lw), "+
     "marker, markeredgecolor (mec), markeredgewidth (mew), markerfacecolor "+
     "(mfc), markerfacecoloralt (mfcalt), markersize (ms). For example: "+
     "o2graph -create x 0 10 0.2 -function sin(x) y -plot x y "+
     "lw=0,marker='+' -show"],
    ["hist_2d","den-plot","Create a density plot from a hist_2d object",
     "[kwargs]","Create a density plot from the current histogram (assuming "+
     "equally-spaced bins). Logarithmic x- or y-axes are handled by taking "+
     "the base 10 log of the x- or y-grids specified in the hist_2d object "+
     "before plotting. A z-axis density legend is print on the RHS if colbar "+
     "is set to 1 before plotting. If z-axis limits are specified, then "+
     "values larger than the upper limit are set equal to the upper limit "+
     "and values smaller than the lower limit are set equal to the lower "+
     "limit before plotting."],
    ["tensor","den-plot","Create a density plot from a tensor object",
     "[index_1 index_2] [kwargs]",
     "Create a density plot from the current tensor. "+
     "If the tensor has rank 2 and the indices are not specifed, then "+
     "plot the first index along the x-axis and the second index along "+
     "the y-axis. "+
     "A z-axis density legend is print on the RHS if colbar "+
     "is set to 1 before plotting. If z-axis limits are specified, then "+
     "values larger than the upper limit are set equal to the upper limit "+
     "and values smaller than the lower limit are set equal to the lower "+
     "limit before plotting."],
    ["tensor<int>","den-plot","Create a density plot from a tensor object",
     "[index_1 index_2] [kwargs]",
     "Create a density plot from the current tensor. "+
     "If the tensor has rank 2 and the indices are not specifed, then "+
     "plot the first index along the x-axis and the second index along "+
     "the y-axis. "+
     "A z-axis density legend is print on the RHS if colbar "+
     "is set to 1 before plotting. If z-axis limits are specified, then "+
     "values larger than the upper limit are set equal to the upper limit "+
     "and values smaller than the lower limit are set equal to the lower "+
     "limit before plotting."],
    ["tensor<size_t>","den-plot","Create a density plot from a tensor object",
     "[index_1 index_2] [kwargs]",
     "Create a density plot from the current tensor. "+
     "If the tensor has rank 2 and the indices are not specifed, then "+
     "plot the first index along the x-axis and the second index along "+
     "the y-axis. "+
     "A z-axis density legend is print on the RHS if colbar "+
     "is set to 1 before plotting. If z-axis limits are specified, then "+
     "values larger than the upper limit are set equal to the upper limit "+
     "and values smaller than the lower limit are set equal to the lower "+
     "limit before plotting."],
    ["tensor_grid","den-plot","Create a density plot from a tensor object",
     "[index_1 index_2] [kwargs]",
     "Create a density plot from the current tensor. "+
     "If the tensor has rank 2 and the indices are not specifed, then "+
     "plot the first index along the x-axis and the second index along "+
     "the y-axis. "+
     "A z-axis density legend is print on the RHS if colbar "+
     "is set to 1 before plotting. If z-axis limits are specified, then "+
     "values larger than the upper limit are set equal to the upper limit "+
     "and values smaller than the lower limit are set equal to the lower "+
     "limit before plotting."],
    ["tensor_grid","yt-add-vol",
     "Add a tensor_grid object as a yt volume source",
     "","Long desc."]
]
"""
This is a list of 5-element entries:
1: object type
2: command name
3: short description
4: argument list
5: full help text
"""

param_list=[
    ["colbar","If true, den-plot adds a color legend (default False)."],
    ["fig_dict",("Dictionary for figure properties. The default value is "+
                 "blank and implies ('fig_size_x=6.0, fig_size_y=6.0, "+
                 "ticks_in=False, "+
                 "rt_ticks=False, left_margin=0.14, right_margin=0.04, "+
                 "bottom_margin=0.12, top_margin=0.04, fontsize=16') ."+
                 "The x and y sizes of the figure object are in "+
                 "fig_size_x and fig_size_y. The value ticks_in refers "+
                 "to whether or not the ticks are inside or outside the "+
                 "plot. The value of rt_ticks refers to whether or not "+
                 "tick marks are plotted on the right and top sides of "+
                 "the plot. The font size parameter is multiplied by 0.8 "+
                 "and then used for the axis labels.")],
    ["font","Font scaling for text objects (default 16)."],
    ["logx","If true, use a logarithmic x-axis (default False)."],
    ["logy","If true, use a logarithmic y-axis (default False)."],
    ["logz","If true, use a logarithmic z-axis (default False)."],
    ["verbose","Verbosity parameter (default 1)."],
    ["xhi","Upper limit for x-axis (function if starts with '(')."],
    ["xlo","Lower limit for x-axis (function if starts with '(')."],
    ["xset","If true, x-axis limits have been set (default False)."],
    ["xtitle","X-axis title. Latex "+
     "works, e.g. '$\\phi$' and '$\\hat{x}$' (default '')"],
    ["yhi","Upper limit for y-axis (function if starts with '(')."],
    ["ylo","Lower limit for y-axis (function if starts with '(')."],
    ["yset","If true, y-axis limits have been set (default False)."],
    ["ytitle","Y-axis title. Latex "+
     "works, e.g. '$\\phi$' and '$\\hat{x}$' (default '')"],
    ["zlo","Lower limit for z-axis (function if starts with '(')."],
    ["zhi","Upper limit for z-axis (function if starts with '(')."],
    ["zset","If true, z-axis limits have been set (default False)."],
    ["ztitle","Z-axis title. Latex "+
     "works, e.g. '$\\phi$' and '$\\hat{x}$' (default '')"],
]
"""
List of o2sclpy parameters

A list of 2-element entries, name and description
"""

yt_param_list=[
    ["yt_axis","If true, plot a 3D axis."],
    ["yt_axis_color","Color for the 3D axis."],
    ["yt_axis_labels_flat",
     "If true, force the axis labels to be parallel to the camera."],
    ["yt_resolution","The rendering resolution (default [512,512])."],
    ["yt_focus","The camera focus (default [0.5,0.5,0.5])."],
    ["yt_position","The camera position."],
    ["yt_path","The animation path."]
]
"""
List of yt parameters for o2sclpy

A list of 2-element entries, name and description
"""

def slack_notify(webhook_url,channel_name,title,
                 message,subtitle='',emoji=':computer:'):
    """
    A function which sends a slack notification

    Based in part on:
    https://www.amphioxus.org/content/slack-notifications-scripts#python
    https://www.webpagefx.com/tools/emoji-cheat-sheet/ , and
    https://github.com/sulhome/bash-slack
    """

    # Formulate message
    if subtitle!='':
        msgdata={
            "channel": channel_name,
            "username": socket.gethostname(),
            "icon_emoji": emoji,
            "attachments": [
                {
                    "fallback": title,
                    "color": "good",
                    "title": title,
                    "fields": [{
                        "title": subtitle,
                        "value": message,
                        "short": False
                    }]
                }
            ]
        }
    else:
        msgdata={
            "channel": channel_name,
            "username": socket.gethostname(),
            "icon_emoji": emoji,
            "attachments": [
                {
                    "fallback": title,
                    "color": "good",
                    "title": title,
                    "fields": [{
                        "value": message,
                        "short": False
                    }]
                }
            ]
        }
    
    # Contact slack
    response=requests.post(webhook_url,data=json.dumps(msgdata),
                           headers={'Content-Type': 'application/json'}
    )

    # If error is returned
    if response.status_code!=200:
        str_temp=('Request to Slack returned '+
                  'error:\n{}. Response is:\n{}')
        raise ValueError(str_temp.format(response.status_code,
                                         response.text))
    
def force_bytes(obj):
    """
    This function returns the bytes object corresponding to ``obj``
    in case it is a string using UTF-8. 
    """
    if isinstance(obj,numpy.bytes_)==False and isinstance(obj,bytes)==False:
        return bytes(obj,'utf-8')
    return obj

def build_o2scl(verbose=1,release=True):
    """
    This function attempts to automatically build O2scl using 
    homebrew on OSX and snap on Linux.
    """
    
    print('Would you like to try to automatically install O2scl '+
          '(requires sudo)?')
    
    if platform.system()=='Darwin':
        ret=os.system('brew doctor')
        if ret!=0:
            if verbose>0:
                print('Homebrew failed ('+ret+').')
            print('Enter directory')
            dir=''
            if release==True:
                urllib.request.urlretrieve('https://github.com/awsteiner/'+
                                           'o2scl/releases/download/v'+
                                           version+'/'+
                                           'o2scl-'+version+'.tar.gz',
                                           dir+'/o2scl-'+version+'.tar.gz')
            else:
                ret3=os.system('git clone https://github.com/awsteiner/'+
                               'o2scl.git')
            os.system('cd '+dir+'; tar xvzf o2scl-'+version+'.tar.gz; '+
                      './configure; make; make install')
        else:
            ret2=os.system('brew install o2scl --HEAD')
            if ret2==0:
                return 0
            else:
                if verbose>0:
                    print('Homebrew install failed ('+ret2+').')
                return 1
    else:
        ret=os.system('snap -v')
        if ret!=0:
            print('Enter directory')
            dir=''
            if release==True:
                urllib.request.urlretrieve('https://github.com/awsteiner/'+
                                           'o2scl/releases/download/v'+
                                           version+'/'+
                                           'o2scl-'+version+'.tar.gz',
                                           dir+'/o2scl-'+version+'.tar.gz')
            else:
                ret3=os.system('git clone https://github.com/awsteiner/'+
                               'o2scl.git')
            os.system('cd '+dir+'; tar xvzf o2scl-'+version+'.tar.gz; '+
                      './configure; make; sudo make install')
        else:
            ret2=os.system('snap install o2scl --devmode --edge')
                
def link_o2scl(verbose=1,o2scl_cpplib='',o2scl_libdir=''):
    """
    This function attempts to automatically load O2scl as a 
    DLL and returns the O2scl and O2scl_hdf DLL pointers.
    """

    # Handle OSX and Linux separately
    if platform.system()=='Darwin':
    
        if verbose>=2:
            print('Using OSX library rules.')
        
        if (o2scl_cpplib=='' and os.getenv('O2SCL_CPPLIB') is not None
            and force_bytes(os.getenv('O2SCL_CPPLIB'))!=b'None'):
            o2scl_cpplib=os.getenv('O2SCL_CPPLIB')
            if verbose>0:
                print('Value of o2scl_cpplib is ',o2scl_cpplib,'.')
        elif verbose>=2:
            print('Value of o2scl_cpplib is ',o2scl_cpplib,'.')
      
        if o2scl_cpplib!='':
            systcpp=ctypes.CDLL(o2scl_cpplib,mode=ctypes.RTLD_GLOBAL)
            if verbose>0:
                print('Loaded system C++ library.')
      
        rl=ctypes.CDLL('/usr/lib/libreadline.dylib',
                       mode=ctypes.RTLD_GLOBAL)
        if verbose>0:
            print('Loaded readline.')
          
        if (o2scl_libdir=='' and os.getenv('O2SCL_LIB') is not None and
            force_bytes(os.getenv('O2SCL_LIB'))!=b'None'):
            o2scl_libdir=os.getenv('O2SCL_LIB')
            if verbose>0:
                print('Value of o2scl_libdir is ',o2scl_libdir,'.')
        elif verbose>=2:
                print('Value of o2scl_libdir is ',o2scl_libdir,'.')
          
        if o2scl_libdir!='':
            try:
                o2scl=ctypes.CDLL(o2scl_libdir+'/libo2scl.dylib',
                                  mode=ctypes.RTLD_GLOBAL)
            except:
                print('O2scl not found.')
                ret=build_o2scl()
                if ret==0:
                    o2scl=ctypes.CDLL(o2scl_libdir+'/libo2scl.dylib',
                                      mode=ctypes.RTLD_GLOBAL)
                else:
                    return 3
                
            if verbose>0:
                print('Loaded o2scl.')
            o2scl_hdf=ctypes.CDLL(o2scl_libdir+'/libo2scl_hdf.dylib',
                                  mode=ctypes.RTLD_GLOBAL)
            if verbose>0:
                print('Loaded o2scl_hdf.')
        else:
            o2scl=ctypes.CDLL('libo2scl.dylib',mode=ctypes.RTLD_GLOBAL)
            if verbose>0:
                print('Loaded o2scl.')
            o2scl_hdf=ctypes.CDLL('libo2scl_hdf.dylib',
                                  mode=ctypes.RTLD_GLOBAL)
            if verbose>0:
                print('Loaded o2scl_hdf.')
    
    else:
    
        stdcpp=ctypes.CDLL(find_library("stdc++"),mode=ctypes.RTLD_GLOBAL)
        if verbose>0:
            print('Loaded system C++ library.')
        
        if (o2scl_libdir=='' and os.getenv('O2SCL_LIB') is not None and
            force_bytes(os.getenv('O2SCL_LIB'))!=b'None'):
            o2scl_libdir=os.getenv('O2SCL_LIB')
            print('Set o2scl-libdir to',o2scl_libdir)
          
        if o2scl_libdir=='':
            o2scl=ctypes.CDLL(find_library("o2scl"),mode=ctypes.RTLD_GLOBAL)
            if verbose>0:
                print('Loaded o2scl.')
            o2scl_hdf=ctypes.CDLL(find_library("o2scl_hdf"),
                                mode=ctypes.RTLD_GLOBAL)
            if verbose>0:
                print('Loaded o2scl_hdf.')
        else:
            o2scl=ctypes.CDLL(o2scl_libdir+'/libo2scl.so',
                              mode=ctypes.RTLD_GLOBAL)
            if verbose>0:
                print('Loaded o2scl.')
            o2scl_hdf=ctypes.CDLL(o2scl_libdir+'/libo2scl_hdf.so',
                                  mode=ctypes.RTLD_GLOBAL)
            if verbose>0:
                print('Loaded o2scl_hdf.')

    return (o2scl,o2scl_hdf)
    

class cloud_file:
    """
    A class to manage downloading files from the internet.

    .. warning:: This class has several potential security issues
                 (even if the md5 sum is verified) and should not be
                 used without due care.
    """
    
    force_subdir=True
    """
    If true, force the same subdirectory structure
    """
    env_var=''
    """
    The environment variable which specifies the data directory
    """
    verbose=1
    """
    The verbosity parameter
    """

    # These are commented out until the code is rewritten to
    # allow for them
    #username=''
    #The HTTP username
    #password=''
    #The HTTP password

    def md5(fname):
        """
        Compute the md5 hash of the specified file. This function
        reads 4k bytes at a time and updates the hash for each
        read in order to prevent from having to read the entire
        file in memory at once.
        """
        hash_md5 = hashlib.md5()
        with open(fname, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    
    def download_file(self,filename,url,md5sum,directory):
        """
        This function proceeds in the following way:

        First, if ``directory`` is not then the function tries to find
        the requested directory. If it is not found, then ``mkdir -p``
        is used to create it. If this doesn't work, then a
        ``FileNotFoundError`` exception is thrown.

        The function then looks for the requested file in the
        directory. If the file is found
        and ``md5sum`` is not empty, then it compares it to the MD5
        checksum of the file.

        If the file is not found or if the checksum was specified
        and didn't match, then this function prompts the user
        to proceed before using
        ``urllib.request.urlretrieve()`` to download the file from
        ``url``. Afterwards, the MD5 checksum is checked again. 
        If the file cannot be found or if the checksum doesn't
        match, a ``ConnectionError`` exception is thrown.
        Otherwise, the function was successful, and the full filename 
        (including subdirectory if applicable) is returned.

        This function works similarly to the C++ O\ :sub:`2`\ scl
        function ``o2scl::cloud_file::get_file_hash()``.
        """
        
        # Test for the existence of the directory and create it if
        # necessary
        if directory!='':
            if os.path.isdir(directory)==False:
                if verbose>0:
                    print('Directory '+directory+'not found.')
                    print('Trying to automatically create using "mkdir -p"')
                cmd='mkdir -p '+directory
                ret=os.system(cmd)
                if ret!=0:
                    raise FileNotFoundError('Directory does '+
                                            'not exist and failed to create.')
                
        # The local filename
        full_name=directory+'/'+filename

        # Check the hash
        hash_match=False
        if md5sum=='':
            hash_match=True
        elif os.path.isfile(full_name)==True:
            mhash2=mda5(full_name)
            if md5sum==mhash2:
                hash_match=True
            elif verbose>0:
                print('Hash of file',full_name,'did not match',md5sum)
        elif verbose>0:
            print('Could not find file',full_name)
            
        # Now download the file if it's not already present
        if hash_match==False or os.path.isfile(full_name)==False:
            response=input('Hash did not match or data file '+full_name+
                           ' not found. Download (y/Y/n/N)? ')
            ret=1
            if response=='y' or response=='Y':
                if verbose>0:
                    print('Trying to download:')
                urllib.request.urlretrieve(url,full_name)
                ret=0
            if ret==0:
                mhash2=mda5(full_name)
                if md5sum!=mhash2:
                    raise ConnectionError('Downloaded file but '+
                                          'has does not match.')
            if ret!=0:
                raise ConnectionError('Failed to obtain data file.')
    
        # Return 0 for success
        return 0

class hdf5_reader:
    """
    Class to read an O2scl object from an HDF5 file. This is
    used by :py:class:`o2sclpy.plotter` to read HDF5 files.
    """

    list_of_dsets=[]
    """
    Data set list used by :py:func:`cloud_file.hdf5_is_object_type`.
    """
    search_type=''
    """
    O2scl type used by :py:func:`cloud_file.hdf5_is_object_type`.
    """

    def hdf5_is_object_type(self,name,obj):
        """
        This is an internal function not intended for use by the end-user.
        If object ``obj`` named ``name`` is of type 'search_type',
        then this function adds that name to 'list_of_dsets'
        """
        # Convert search_type to a bytes object
        search_type_bytes=bytes(self.search_type,'utf-8')
        if isinstance(obj,h5py.Group):
            if 'o2scl_type' in obj.keys():
                o2scl_type_dset=obj['o2scl_type']
                if o2scl_type_dset.__getitem__(0) == search_type_bytes:
                    self.list_of_dsets.append(name)
        return

    def h5read_first_type(self,fname,loc_type):
        """
        Read the first object of type ``loc_type`` from file named ``fname``
        """
        del self.list_of_dsets[:]
        self.search_type=loc_type
        file=h5py.File(fname,'r')
        file.visititems(self.hdf5_is_object_type)
        if len(self.list_of_dsets)==0:
            str='Could not object of type '+loc_type+' in file '+fname+'.'
            raise RuntimeError(str)
        return file[self.list_of_dsets[0]]

    def h5read_name(self,fname,name):
        """
        Read object named ``name`` from file named ``fname``
        """
        file=h5py.File(fname,'r')
        obj=file[name]
        o2scl_type_dset=obj['o2scl_type']
        loc_type=o2scl_type_dset.__getitem__(0)
        return (obj,loc_type)
    
    def h5read_type_named(self,fname,loc_type,name):
        """
        Read object of type ``loc_type`` named ``name`` from file 
        named ``fname``
        """
        del self.list_of_dsets[:]
        self.search_type=loc_type
        file=h5py.File(fname,'r')
        file.visititems(self.hdf5_is_object_type)
        if name in self.list_of_dsets:
            return file[name]
        str='No object of type '+loc_type+' named '+name+' in file '+fname+'.'
        raise RuntimeError(str)
        return

# This function is probably best replaced by get_str_array() below
#
# def parse_col_names(dset):
#     nc=dset['nc'].__getitem__(0)
#     nw=dset['nw'].__getitem__(0)
#     counter=dset['counter']
#     data=dset['data']
#     clist=[]
#     k=0
#     for i in range(0,nw):
#         column=''
#         for j in range(0,counter[i]):
#             column=column+str(unichr(data[k]))
#             k=k+1
#         clist.append(column)
#     return clist

def default_plot(left_margin=0.14,bottom_margin=0.12,
                 right_margin=0.04,top_margin=0.04,fontsize=16,
                 fig_size_x=6.0,fig_size_y=6.0,ticks_in=False,
                 rt_ticks=False):
    """
    This function sets up the o2sclpy ``matplotlib`` defaults.
    It returns a pair of objects, the figure object and axes object.
    """
    plot.rc('text',usetex=True)
    plot.rc('font',family='serif')
    plot.rcParams['lines.linewidth']=0.5
    fig=plot.figure(1,figsize=(fig_size_x,fig_size_y))
    fig.set_facecolor('white')
    ax=plot.axes([left_margin,bottom_margin,
                  1.0-left_margin-right_margin,1.0-top_margin-bottom_margin])
    ax.minorticks_on()
    if ticks_in:
        ax.tick_params('both',length=12,width=1,which='major',direction='in')
        ax.tick_params('both',length=5,width=1,which='minor',direction='in')
    else:
        ax.tick_params('both',length=12,width=1,which='major')
        ax.tick_params('both',length=5,width=1,which='minor')
    if rt_ticks:
        ax.tick_params('x',which='both',top=True,bottom=True)
        ax.tick_params('y',which='both',left=True,right=True)
    ax.tick_params('both',length=5,width=1,which='minor')
    ax.tick_params(labelsize=fontsize*0.8)
    plot.grid(False)
    return (fig,ax)
    
def get_str_array(dset):
    """
    Extract a string array from O2scl HDF5 dataset ``dset`` as a list
    """
    nw=dset['nw'][0]
    nc=dset['nc'][0]
    data=dset['data']
    counter=dset['counter']
    char_counter=1
    word_counter=0
    list=[]
    col=''
    for ix in range(0,nc):
        # Skip empty strings in the array
        done=0
        while done==0:
            if word_counter==nw:
                done=1
            elif counter[word_counter]==0:
                word_counter=word_counter+1
                list.append('')
            else:
                done=1
        col=col+str(chr(data[ix]))
        if char_counter==counter[word_counter]:
            list.append(col)
            col=''
            word_counter=word_counter+1
            char_counter=1
        else:
            char_counter=char_counter+1
    # We're done with the characters, but there are some blank
    # strings left. Add the appropriate blanks at the end.
    while word_counter<nw:
        list.append('')
        word_counter=word_counter+1
    return list

def parse_arguments(argv,verbose=0):
    """
    Old command-line parser (this is currently unused and
    it's not clear if it will be useful in the future).
    """
    list=[]
    unproc_list=[]
    if verbose>1:
        print('Number of arguments:', len(argv), 'arguments.')
        print('Argument List:', str(argv))
    ix=1
    while ix<len(argv):
        if verbose>1:
            print('Processing index',ix,'with value',argv[ix],'.')
        # Find first option, at index ix
        initial_ix_done=0
        while initial_ix_done==0:
            if ix==len(argv):
                initial_ix_done=1
            elif argv[ix][0]=='-':
                initial_ix_done=1
            else:
                if verbose>1:
                     print('Adding',argv[ix],' to unprocessed list.')
                unproc_list.append(argv[ix])
                ix=ix+1
        # If there is an option, then ix is its index
        if ix<len(argv):
            list_one=[]
            # Strip single and double dashes
            cmd_name=argv[ix][1:]
            if cmd_name[0]=='-':
                cmd_name=cmd_name[1:]
            # Add command name to list
            list_one.append(cmd_name)
            if verbose>1:
                print('Found option',cmd_name,'at index',ix)
            # Set ix_next to the next option, or to the end if
            # there is no next option
            ix_next=ix+1
            ix_next_done=0
            while ix_next_done==0:
                if ix_next==len(argv):
                    ix_next_done=1
                elif argv[ix_next][0]=='-':
                    ix_next_done=1
                else:
                    if verbose>1:
                        print('Adding '+argv[ix_next]+' with index '+
                              str(ix_next)+' to list for '+cmd_name)
                    list_one.append(argv[ix_next])
                    ix_next=ix_next+1
            list.append(list_one)
            ix=ix_next
    return (list,unproc_list)

def string_to_dict(s):
    """
    Convert a string to a dictionary, with extra processing for some
    matplotlib keyword arguments which are expected to have integer or
    floating point values.
    """
    # First split into keyword = value pairs
    arr=s.split(',')
    # Create empty dictionary
    dct={}
    # If we need to skip arguments
    skip=0

    if len(s)==0:
        return dct
    
    for i in range(0,len(arr)):

        if skip>0:
            skip=skip-1
        else:
            # For each pair, split keyword and value.
            arr2=arr[i].split('=')
    
            # Remove quotes if necessary
            if arr2[1][0]=='\'' and arr2[1][len(arr2[1])-1]=='\'':
                arr2[1]=arr2[1][1:len(arr2[1])-1]
            if arr2[1][0]=='"' and arr2[1][len(arr2[1])-1]=='"':
                arr2[1]=arr2[1][1:len(arr2[1])-1]

            # If one of the entries is arrowstyle, then combine
            # it with the head_width, head_length, and tail_width
            # options if they are present
            if arr2[0]=='arrowstyle':
                for j in range(0,len(arr)):
                    if arr[j].split('=')[0]=='head_width':
                        arr2[1]=arr2[1]+',head_width='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='head_length':
                        arr2[1]=arr2[1]+',head_length='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='tail_width':
                        arr2[1]=arr2[1]+',tail_width='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='shrink_factor':
                        arr2[1]=arr2[1]+',shrink_factor='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='widthA':
                        arr2[1]=arr2[1]+',widthA='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='widthB':
                        arr2[1]=arr2[1]+',widthB='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='lengthB':
                        arr2[1]=arr2[1]+',lengthB='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='as_angleB':
                        arr2[1]=arr2[1]+',angleB='+arr[j].split('=')[1]
                print('Found arrowstyle option, reprocessed:',arr2[1])
            if arr2[0]=='connectionstyle':
                for j in range(0,len(arr)):
                    if arr[j].split('=')[0]=='angleA':
                        arr2[1]=arr2[1]+',angleA='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='cs_angleB':
                        arr2[1]=arr2[1]+',angleB='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='armA':
                        arr2[1]=arr2[1]+',armA='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='armB':
                        arr2[1]=arr2[1]+',armB='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='rad':
                        arr2[1]=arr2[1]+',rad='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='fraction':
                        arr2[1]=arr2[1]+',fraction='+arr[j].split('=')[1]
                    if arr[j].split('=')[0]=='angle':
                        arr2[1]=arr2[1]+',angle='+arr[j].split('=')[1]
                print('Found connectionstyle option, reprocessed:',arr2[1])
                
            # convert strings to numbers if necessary
            if arr2[0]=='zorder':
                arr2[1]=float(arr2[1])
            if arr2[0]=='lw':
                arr2[1]=float(arr2[1])
            if arr2[0]=='alpha':
                arr2[1]=float(arr2[1])
            if arr2[0]=='shrinkA':
                arr2[1]=int(arr2[1])
            if arr2[0]=='shrinkB':
                arr2[1]=int(arr2[1])
            if arr2[0]=='bins':
                arr2[1]=int(arr2[1])
            if arr2[0]=='fig_size_x':
                arr2[1]=float(arr2[1])
            if arr2[0]=='fig_size_y':
                arr2[1]=float(arr2[1])
            if arr2[0]=='left_margin':
                arr2[1]=float(arr2[1])
            if arr2[0]=='right_margin':
                arr2[1]=float(arr2[1])
            if arr2[0]=='top_margin':
                arr2[1]=float(arr2[1])
            if arr2[0]=='bottom_margin':
                arr2[1]=float(arr2[1])
            if arr2[0]=='left':
                arr2[1]=float(arr2[1])
            if arr2[0]=='right':
                arr2[1]=float(arr2[1])
            if arr2[0]=='top':
                arr2[1]=float(arr2[1])
            if arr2[0]=='bottom':
                arr2[1]=float(arr2[1])
            if arr2[0]=='wspace':
                arr2[1]=float(arr2[1])
            if arr2[0]=='hspace':
                arr2[1]=float(arr2[1])
            if arr2[0]=='fontsize':
                arr2[1]=float(arr2[1])
            if arr2[0]=='sharex':
                if arr2[1]=='True':
                    arr2[1]=True
                else:
                    arr2[1]=False
            if arr2[0]=='sharey':
                if arr2[1]=='True':
                    arr2[1]=True
                else:
                    arr2[1]=False
            if arr2[0]=='squeeze':
                if arr2[1]=='True':
                    arr2[1]=True
                else:
                    arr2[1]=False
            if arr2[0]=='fill':
                if arr2[1]=='True':
                    arr2[1]=True
                else:
                    arr2[1]=False
            if arr2[0]=='ticks_in':
                if arr2[1]=='True':
                    arr2[1]=True
                else:
                    arr2[1]=False
            if arr2[0]=='rt_ticks':
                if arr2[1]=='True':
                    arr2[1]=True
                else:
                    arr2[1]=False
            if arr2[0]=='color' and arr[i][5]=='=' and arr[i][6]=='(':
                arr2[1]=arr2[1]+','+arr[i+1]+','+arr[i+2]
                skip=2
                arr2[1]=arr2[1][1:len(arr2[1])-1]
                arr3=arr2[1].split(',')
                arr2[1]=(float(arr3[0]),float(arr3[1]),float(arr3[2]))

            # assign to dictionary (except for arrowstyle and
            # connectionstyle options which are handled separately
            # above)
            if (arr2[0]!='head_width' and arr2[0]!='head_length' and
                arr2[0]!='tail_width' and arr2[0]!='rad' and
                arr2[0]!='angleA' and arr2[0]!='as_angleB' and
                arr2[0]!='armA' and arr2[0]!='armB' and
                arr2[0]!='angle' and arr2[0]!='fraction' and
                arr2[0]!='shrink_factor' and arr2[0]!='widthA' and
                arr2[0]!='lengthB' and arr2[0]!='widthB' and
                arr2[0]!='cs_angleB'):
                dct[arr2[0]]=arr2[1]
        
    return dct

class plot_base:
    """
    A base class for plotting classes :py:class:`o2sclpy.plotter` and
    :py:class:`o2sclpy.o2graph_plotter` . The principal purpose
    of this class is just to provide some additional simplification
    to python code which makes plots using matplotlib.
    """

    axes=0
    """ 
    Axis object
    """
    axis_list=0
    """
    2D array of axis objects when subplots is used
    """
    fig=0
    """ 
    Figure object
    """
    canvas_flag=False
    """
    If True, then the figure and axes objects have been created
    (default False)
    """

    # Quantities modified by set/get
    
    logx=False
    """
    If True, then use a logarithmic x axis (default False)
    """
    logy=False
    """
    If True, then use a logarithmic y axis (default False)
    """
    logz=False
    """
    If True, then use a logarithmic z axis (default False)
    """
    xtitle=''
    """
    Title for x axis (default '')
    """
    ytitle=''
    """
    Title for y axis (default '')
    """
    ztitle=''
    """
    Title for z axis (default '')
    """
    xlo=0
    """
    Lower limit for x axis (default 0)
    """
    xhi=0
    """
    Upper limit for x axis (default 0)
    """
    xset=False
    """ 
    If True, then the x axis limits have been set (default False)
    """
    ylo=0
    """
    Lower limit for y axis (default 0)
    """
    yhi=0
    """
    Upper limit for y axis (default 0)
    """
    yset=False
    """ 
    If True, then the y axis limits have been set (default False)
    """
    zlo=0
    """
    Lower limit for z axis (default 0)
    """
    zhi=0
    """
    Upper limit for z axis (default 0)
    """
    zset=False
    """ 
    If True, then the z axis limits have been set (default False)
    """
    verbose=1
    """
    Verbosity parameter (default 1)
    """
    colbar=False
    """
    If True, then include a color legend for density plots (default False)
    """
    left_margin=0.14
    """
    Left plot margin (default 0.14)
    """
    right_margin=0.04
    """
    Right plot margin (default 0.04)
    """
    top_margin=0.04
    """
    Top plot margin (default 0.04)
    """
    bottom_margin=0.12
    """
    Bottom plot margin (default 0.12)
    """
    font=16
    """
    Font size for :py:func:`o2sclpy.plot_base.text()`,
    :py:func:`o2sclpy.plot_base.ttext()`, and axis titles (default
    16). Axis labels are set by this size times 0.8 .
    """
    fig_dict=''
    """
    A dictionary which refers to the figure and axis defaults for
    :py:func:`o2sclpy.default_plot()`. The default value is
    ``('fig_size_x=6.0,fig_size_y=6.0,ticks_in=False,'+
    'rt_ticks=False,left_margin=0.14,right_margin=0.04,'+
    'bottom_margin=0.12,top_margin=0.04,fontsize=16')`` . The x and y
    sizes of the figure object are in fig_size_x and fig_size_y. The
    value ticks_in refers to whether or not the ticks are inside or
    outside the plot. The value of rt_ticks refers to whether or not
    tick marks are plotted on the right and top sides of the plot. The
    font size parameter is multiplied by 0.8 and then used for the
    axis labels.
    """
    ticks_in=False
    """
    If true, move the ticks inside (default False)
    """
    rt_ticks=False
    """
    If true, include ticks on right side and top (default False)
    """
    yt_axis_color=[1.0,1.0,1.0,0.5]
    """ 
    Color and alpha for the yt axis (default [1.0,1.0,1.0,0.5])
    """
    yt_axis_labels_flat=True
    """ 
    If true, axis labels are always parallel to the camera (default True)
    """
    yt_resolution=(512,512)
    """
    Resolution for yt rendering (default [512,512])
    """
    yt_focus=[0.5,0.5,0.5]
    """
    yt camera focus (default [1.5,0.6,0.7])
    """
    yt_position=[1.5,0.6,0.7]
    """
    yt camera position
    """
    yt_path=['','','']
    """
    yt camera path (default ['','',''])
    """
    yt_tf=0
    """
    The yt transfer function
    """
    new_cmaps_defined=False
    """
    True if new colormaps were defined with 'new-cmaps'
    """
    
    def new_cmaps(self):
        """
        Add a few new colormaps
        """
        # A white to red colormap
        cdict={'red': ((0.0,1.0,1.0),(1.0,1.0,1.0)),
               'green': ((0.0,1.0,1.0),(1.0,0.0,0.0)),
               'blue': ((0.0,1.0,1.0),(1.0,0.0,0.0))}
        reds2=LinearSegmentedColormap('reds2',cdict)
        plot.register_cmap(cmap=reds2)
        # A new version of the ``jet`` colormap which starts with
        # white instead of blue. In order, the index colors are white,
        # blue, green, yellow, orange, and red
        cdict={'red': ((0.0,1.0,1.0),(0.2,0.0,0.0),
                       (0.4,0.0,0.0),(0.6,1.0,1.0),
                       (0.8,1.0,1.0),(1.0,1.0,1.0)),
               'green': ((0.0,1.0,1.0),(0.2,0.0,0.0),
                         (0.4,0.5,0.5),(0.6,1.0,1.0),
                         (0.8,0.6,0.6),(1.0,0.0,0.0)),
               'blue': ((0.0,1.0,1.0),(0.2,1.0,1.0),
                        (0.4,0.0,0.0),(0.6,0.0,0.0),
                        (0.8,0.0,0.0),(1.0,0.0,0.0))}
        jet2=LinearSegmentedColormap('jet2',cdict)
        plot.register_cmap(cmap=jet2)
        # A new version of the ``pastel`` colormap which starts with
        # white instead of blue. In order, the index colors are white,
        # blue, green, yellow, orange, and red
        cdict={'red': ((0.0,1.0,1.0),(0.2,0.3,0.3),
                       (0.4,0.3,0.3),(0.6,1.0,1.0),
                       (0.8,1.0,1.0),(1.0,1.0,1.0)),
               'green': ((0.0,1.0,1.0),(0.2,0.3,0.3),
                         (0.4,0.5,0.5),(0.6,1.0,1.0),
                         (0.8,0.6,0.6),(1.0,0.3,0.3)),
               'blue': ((0.0,1.0,1.0),(0.2,1.0,1.0),
                        (0.4,0.3,0.3),(0.6,0.3,0.3),
                        (0.8,0.3,0.3),(1.0,0.3,0.3))}
        pastel2=LinearSegmentedColormap('pastel2',cdict)
        plot.register_cmap(cmap=pastel2)
        # A white to green colormap
        cdict={'red': ((0.0,1.0,1.0),(1.0,0.0,0.0)),
               'green': ((0.0,1.0,1.0),(1.0,1.0,1.0)),
               'blue': ((0.0,1.0,1.0),(1.0,0.0,0.0))}
        greens2=LinearSegmentedColormap('greens2',cdict)
        plot.register_cmap(cmap=greens2)
        # A white to blue colormap
        cdict={'red': ((0.0,1.0,1.0),(1.0,0.0,0.0)),
               'green': ((0.0,1.0,1.0),(1.0,0.0,0.0)),
               'blue': ((0.0,1.0,1.0),(1.0,1.0,1.0))}
        blues2=LinearSegmentedColormap('blues2',cdict)
        plot.register_cmap(cmap=blues2)
        new_cmaps_defined=True
        
    def set(self,name,value):
        """
        Set the value of parameter named ``name`` to value ``value``
        """
        if name=='logx':
            if value=='False' or value=='0':
                self.logx=False
            else:
                self.logx=True
        elif name=='logy':
            if value=='False' or value=='0':
                self.logy=False
            else:
                self.logy=True
        elif name=='logz':
            if value=='False' or value=='0':
                self.logz=False
            else:
                self.logz=True
        elif name=='xtitle':
            self.xtitle=value
        elif name=='ytitle':
            self.ytitle=value
        elif name=='ztitle':
            self.ztitle=value
        elif name=='xlo':
            if value[0]=='(':
                self.xlo=float(eval(value))
            else:
                self.xlo=float(value)
            self.xset=True
        elif name=='xhi':
            if value[0]=='(':
                self.xhi=float(eval(value))
            else:
                self.xhi=float(value)
            self.xset=True
        elif name=='xset':
            if value=='False' or value=='0':
                self.xset=False
            else:
                self.xset=True
        elif name=='ylo':
            if value[0]=='(':
                self.ylo=float(eval(value))
            else:
                self.ylo=float(value)
            self.yset=True
        elif name=='yhi':
            if value[0]=='(':
                self.yhi=float(eval(value))
            else:
                self.yhi=float(value)
            self.yset=True
        elif name=='yset':
            if value=='False' or value=='0':
                self.xset=False
            else:
                self.xset=True
        elif name=='zlo':
            if value[0]=='(':
                self.zlo=float(eval(value))
            else:
                self.zlo=float(value)
            self.zset=True
        elif name=='zhi':
            if value[0]=='(':
                self.zhi=float(eval(value))
            else:
                self.zhi=float(value)
            self.zset=True
        elif name=='zset':
            if value=='False' or value=='0':
                self.zset=False
            else:
                self.zset=True
        elif name=='verbose':
            self.verbose=int(value)
        elif name=='colbar':
            if value=='False' or value=='0':
                self.colbar=False
            else:
                self.colbar=True
        elif name=='font':
            self.font=float(value)
        elif name=='fig_dict':
            self.fig_dict=value
        elif name=='yt_axis':
            print('set')
        elif name=='yt_axis_color':
            print('set')
        elif name=='yt_axis_labels_flat':
            print('set')
        elif name=='yt_axis_resolution':
            print('set')
        elif name=='yt_focus':
            print('set')
        elif name=='yt_position':
            print('set')
        elif name=='yt_path':
            print('set')
        else:
            print('No variable named',name)
            
        if self.verbose>0:
            print('Set',name,'to',value)
            
        return

    def get(self,name):
        """
        Output the value of parameter named ``name``
        """
        if name=='colbar':
            print('The value of colbar is',self.colbar,'.')
        if name=='logx':
            print('The value of logx is',self.logx,'.')
        if name=='logy':
            print('The value of logy is',self.logy,'.')
        if name=='logz':
            print('The value of logz is',self.logz,'.')
        if name=='verbose':
            print('The value of verbose is',self.verbose,'.')
        if name=='xhi':
            print('The value of xhi is',self.xhi,'.')
        if name=='xlo':
            print('The value of xlo is',self.xlo,'.')
        if name=='xset':
            print('The value of xset is',self.xset,'.')
        if name=='xtitle':
            print('The value of xtitle is',self.xtitle,'.')
        if name=='yhi':
            print('The value of yhi is',self.yhi,'.')
        if name=='ylo':
            print('The value of ylo is',self.ylo,'.')
        if name=='yset':
            print('The value of yset is',self.yset,'.')
        if name=='ytitle':
            print('The value of ytitle is',self.ytitle,'.')
        if name=='ztitle':
            print('The value of ztitle is',self.ztitle,'.')
        if name=='zhi':
            print('The value of zhi is',self.zhi,'.')
        if name=='zlo':
            print('The value of zlo is',self.zlo,'.')
        if name=='zset':
            print('The value of zset is',self.zset,'.')
        if name=='fig-dict':
            print('The value of fig-dict is',self.fig_dict,'.')
        return

    def reset_xlimits(self):
        """
        Reset x axis limits
        """
        self.xset=False
        return

    def xlimits(self,xlo,xhi):
        """
        Set the x-axis limits
        """
        self.xlo=xlo
        self.xhi=xhi
        self.xset=True
        if self.canvas_flag==True:
            self.axes.set_xlim(self.xlo,self.xhi)
        return

    def reset_ylimits(self):
        """
        Reset y axis limits
        """
        self.yset=False
        return

    def ylimits(self,ylo,yhi):
        """
        Set the y-axis limits
        """
        self.ylo=ylo
        self.yhi=yhi
        self.yset=True
        if self.canvas_flag==True:
            self.axes.set_ylim(self.ylo,self.yhi)
        return

    def reset_zlimits(self):
        """
        Reset z axis limits
        """
        self.zset=False
        return

    def zlimits(self,zlo,zhi):
        """
        Set the z-axis limits
        """
        self.zlo=zlo
        self.zhi=zhi
        self.zset=True
        #if self.canvas_flag==True:
        #plot.zlim([zlo,zhi])
        return

    def line(self,x1,y1,x2,y2,**kwargs):
        """
        Plot a line from :math:`(x_1,y_1)` to :math:`(x_2,y_2)`
        """
        if self.verbose>2:
            print('Line',x1,y1,x2,y1)
        if self.canvas_flag==False:
            self.canvas()
        self.axes.plot([float(eval(x1)),float(eval(x2))],
                       [float(eval(y1)),float(eval(y2))],**kwargs)
        return

    def arrow(self,x1,y1,x2,y2,arrowprops,**kwargs):
        """
        Plot an arrow from :math:`(x_1,y_1)` to :math:`(x_2,y_2)`
        """
        if self.verbose>2:
            print('Arrow',x1,y1,x2,y1,arrowprops)
        if self.canvas_flag==False:
            self.canvas()
        self.axes.annotate("",xy=(float(eval(x2)),float(eval(y2))),
                           xycoords='data',
                           xytext=(float(eval(x1)),float(eval(y1))),
                           textcoords='data',
                           arrowprops=string_to_dict(arrowprops))
        return

    def point(self,xval,yval,**kwargs):
        """
        Plot a point at location (xval,yval)
        """
        if self.verbose>2:
            print('point',xval,yval,kwargs)
        if self.canvas_flag==False:
            self.canvas()
        self.axes.plot([float(eval(xval))],[float(eval(yval))],**kwargs)
        if self.xset==True:
            self.axes.set_xlim(self.xlo,self.xhi)
        if self.yset==True:
            self.axes.set_ylim(self.ylo,self.yhi)
        return

    def rect(self,x1,y1,x2,y2,angle,**kwargs):
        """
        Plot a rectangle from :math:`(x_1,y_1)` to :math:`(x_2,y_2)`
        """
        if self.verbose>2:
            print('Rect',x1,y1,x2,y1)
        if self.canvas_flag==False:
            self.canvas()
        fx1=float(eval(x1))
        fx2=float(eval(x2))
        fy1=float(eval(y1))
        fy2=float(eval(y2))
        left=fx1
        if fx2<fx1:
            left=fx2
        lower=fy1
        if fy2<fy1:
            lower=fy2
        w=abs(fx1-fx2)
        h=abs(fy1-fy2)
        if self.canvas_flag==False:
            self.canvas()
        r=patches.Rectangle((left,lower),w,h,angle,**kwargs)
        self.axes.add_patch(r)
        return

    def show(self):
        """
        Call the ``matplotlib`` show function.
        """
        plot.show()
        return

    def save(self,filename):
        """
        Save plot to file named ``filename``. If the verbose parameter is
        greater than zero, then this function prints the filename to
        the screen.
        """
        if self.verbose>0:
            print('Saving as',filename,'.')
        plot.savefig(filename)
        return

    def ttext(self,tx,ty,textstr,**kwargs):
        """
        Plot text in the native coordinate system using a transAxes
        transformation. This function uses the class font size and and
        centering in the horizontal and vertical directions by
        default. A figure and axes are created using 
        :py:func:`o2sclpy.plot_base.canvas()`,
        if they
        have not been created already. If ``tx`` and ``ty`` are strings, then
        they are passed through the ``eval()`` function and converted to
        floating-point numbers.
        """
        if self.canvas_flag==False:
            self.canvas()
            
        ha_present=False
        for key in kwargs:
            if key=='ha' or key=='horizontalalignment':
                ha_present=True
        if ha_present==False:
            kwargs=dict(kwargs,ha='center')
            
        va_present=False
        for key in kwargs:
            if key=='va' or key=='verticalalignment':
                va_present=True
        if va_present==False:
            kwargs=dict(kwargs,va='center')

        fontsize_present=False
        for key in kwargs:
            if key=='fontsize':
                fontsize_present=True
        if fontsize_present==False:
            kwargs=dict(kwargs,fontsize=self.font)

        transform_present=False
        for key in kwargs:
            if key=='transform':
                transform_present=True
        if transform_present==False:
            kwargs=dict(kwargs,transform=self.axes.transAxes)

        if isinstance(tx,str):
            tx=float(eval(tx))
        if isinstance(ty,str):
            ty=float(eval(ty))

        self.axes.text(tx,ty,textstr,**kwargs)

        return

    def text(self,tx,ty,textstr,**kwargs):
        """Plot text in the axis coordinate system transforming using the
        class font size and and centering in the horizontal and
        vertical directions by default. A figure and axes are created
        using :py:func:`o2sclpy.plot_base.canvas()`, if they have not
        been created already. If ``tx`` and ``ty`` are strings, then
        they are passed through the ``eval()`` function and converted
        to floating-point numbers.
        """
        if self.canvas_flag==False:
            self.canvas()
            
        ha_present=False
        for key in kwargs:
            if key=='ha' or key=='horizontalalignment':
                ha_present=True
        if ha_present==False:
            kwargs=dict(kwargs,ha='center')
            
        va_present=False
        for key in kwargs:
            if key=='va' or key=='verticalalignment':
                va_present=True
        if va_present==False:
            kwargs=dict(kwargs,va='center')

        fontsize_present=False
        for key in kwargs:
            if key=='fontsize':
                fontsize_present=True
        if fontsize_present==False:
            kwargs=dict(kwargs,fontsize=self.font)

        if isinstance(tx,str):
            tx=float(eval(tx))
        if isinstance(ty,str):
            ty=float(eval(ty))

        self.axes.text(tx,ty,textstr,**kwargs)
        
        return

    def textbox(self,tx,ty,str,boxprops,**kwargs):
        """
        Plot text in the axis coordinate system with a box
        """
        if self.canvas_flag==False:
            self.canvas()
            
        ha_present=False
        for key in kwargs:
            if key=='ha':
                ha_present=True
        if ha_present==False:
            kwargs=dict(kwargs,ha='center')
            
        va_present=False
        for key in kwargs:
            if key=='va':
                va_present=True
        if va_present==False:
            kwargs=dict(kwargs,va='center')

        self.axes.text(float(eval(tx)),float(eval(ty)),str,
                       fontsize=self.font,
                       transform=self.axes.transAxes,
                       bbox=string_to_dict(boxprops),**kwargs)
        return

    def subplots(self,nr,nc=0,**kwargs):
        plot.rc('text',usetex=True)
        plot.rc('font',family='serif')
        plot.rcParams['lines.linewidth']=0.5
        self.fig,self.axis_list=plot.subplots(nrows=nr,ncols=nc,**kwargs)
        # Count rows and columns to modify axes
        nr_temp=len(self.axis_list)
        try:
            nc_temp=len(self.axis_list[0])
        except:
            nc_temp=1
        if nc_temp==1:
            for i in range(0,nr_temp):
                self.axis_list[i].tick_params('both',length=5,
                                              width=1,which='minor')
                self.axis_list[i].tick_params(labelsize=self.font*0.8)
        else:
            for i in range(0,nr_temp):
                for j in range(0,nc_temp):
                    self.axis_list[i][j].tick_params('both',length=5,
                                                     width=1,which='minor')
                    self.axis_list[i][j].tick_params(labelsize=self.font*0.8)
        self.canvas_flag=True
        return

    def xtitle(self,xt):
        if xt!='' and xt!='none':
            self.axes.set_xlabel(xt,fontsize=self.font)
            
    def ytitle(self,yt):
        if yt!='' and yt!='none':
            self.axes.set_ylabel(yt,fontsize=self.font)
        
    def selsub(self,nr,nc=0):
        nr_temp=len(self.axis_list)
        try:
            nc_temp=len(self.axis_list[0])
        except:
            nc_temp=1
        if nc_temp==1:
            self.axes=self.axis_list[nr]
        else:
            self.axes=self.axis_list[nr][nc]
        return

    def canvas(self):
        """
        This function creates a default figure using default_plot()
        and axis object using the xtitle and ytitle for the
        axis titles and xlo, xhi, ylo, and yhi for the axis limits.
        """
        if self.verbose>2:
            print('Canvas')
            
        dct=string_to_dict(self.fig_dict)
        (self.fig,self.axes)=default_plot(**dct)
        
        # (self.fig,self.axes)=default_plot(left_margin=self.left_margin,
        #                                   bottom_margin=self.bottom_margin,
        #                                   right_margin=self.right_margin,
        #                                   top_margin=self.top_margin,
        #                                   fontsize=self.font,
        #                                   fig_size_x=self.fig_size_x,
        #                                   fig_size_y=self.fig_size_y,
        #                                   ticks_in=self.ticks_in,
        #                                   rt_ticks=self.rt_ticks)
        
        # Plot limits
        if self.xset==True:
            self.axes.set_xlim(self.xlo,self.xhi)
        if self.yset==True:
            self.axes.set_ylim(self.ylo,self.yhi)
        # Titles
        if self.xtitle!='':
            plot.xlabel(self.xtitle,fontsize=self.font)
        if self.ytitle!='':
            plot.ylabel(self.ytitle,fontsize=self.font)
        self.canvas_flag=True
        return

    def move_labels(self):
        """
        Move tick labels
        """
        for label in self.axes.get_xticklabels():
            t=label.get_position()
            t2=t[0],t[1]-0.01
            label.set_position(t2)
            label.set_fontsize(16)
        for label in self.axes.get_yticklabels():
            t=label.get_position()
            t2=t[0]-0.01,t[1]
            label.set_position(t2)
            label.set_fontsize(16)
        return

class plotter(plot_base):
    """ 
    A class useful for quickly plotting HDF5 data generated
    by O\ :sub:`2`\ scl . This class is a child of the
    :py:class:`o2sclpy.plot_base` class.
    """

    h5r=hdf5_reader()
    """
    Object which handles reading HDF5 files
    """
    dset=0
    """
    The current HDF5 dataset
    """
    dtype=''
    """
    The current type
    """

    def contour_plot(self,level,**kwargs):
        """
        If the current dataset is of type ``vector<contour_line>``, then
        plot the contour lines for the contour level specified in
        ``level``.
        """
        if force_bytes(self.dtype)!=b'vector<contour_line>':
            print('Wrong type',self.dtype,'for contour_plotx.')
            return
        if self.verbose>2:
            print('contour_plot',level,kwargs)
        if self.canvas_flag==False:
            self.canvas()
        n_lines=self.dset['n_lines'][0]
        for i in range(0,n_lines):
            line_level=self.dset['line_'+str(i)+'/level'][0]
            if abs(level-line_level) < 1.0e-7:
                if self.logx==True:
                    if self.logy==True:
                        self.axes.loglog(self.dset['line_'+str(i)+'/x'],
                                    self.dset['line_'+str(i)+'/y'],**kwargs)
                    else:
                        self.axes.semilogx(self.dset['line_'+str(i)+'/x'],
                                      self.dset['line_'+str(i)+'/y'],**kwargs)
                else:
                    if self.logy==True:
                        self.axes.semilogy(self.dset['line_'+str(i)+'/x'],
                                      self.dset['line_'+str(i)+'/y'],**kwargs)
                    else:
                        self.axes.plot(self.dset['line_'+str(i)+'/x'],
                                  self.dset['line_'+str(i)+'/y'],**kwargs)
        return
 
    def plot(self,colx,coly,**kwargs):
        """
        If the current dataset is of type ``table``, then
        plot the two columns specified in ``colx`` and ``coly``.
        Otherwise, if the current dataset is of type 
        ``hist``, then plot the histogram and ignore the
        values of ``colx`` and ``coly``.
        """
        if force_bytes(self.dtype)==b'table':
            if self.verbose>2:
                print('plot',colx,coly,kwargs)
            if self.canvas_flag==False:
                self.canvas()
            if self.logx==True:
                if self.logy==True:
                    self.axes.loglog(self.dset['data/'+colx],
                                self.dset['data/'+coly],**kwargs)
                else:
                    self.axes.semilogx(self.dset['data/'+colx],
                                  self.dset['data/'+coly],**kwargs)
            else:
                if self.logy==True:
                    self.axes.semilogy(self.dset['data/'+colx],
                                  self.dset['data/'+coly],**kwargs)
                else:
                    self.axes.plot(self.dset['data/'+colx],
                              self.dset['data/'+coly],**kwargs)
            if self.xset==True:
                self.axes.set_xlim(self.xlo,self.xhi)
            if self.yset==True:
                self.axes.set_ylim(self.ylo,self.yhi)
        elif force_bytes(self.dtype)==b'hist':
            size=dset['size'][0]
            bins=dset['bins']
            weights=dset['weights']
            rmode=dset['rmode'][0]
            reps=bins[0:size-1]
            for i in range(0,size):
                reps[i]=(bins[i]+bins[i+1])/2
            if self.logx==True:
                if self.logy==True:
                    self.axes.loglog(reps,weights,**kwargs)
                else:
                    self.axes.semilogx(reps,weights,**kwargs)
            else:
                if self.logy==True:
                    self.axes.semilogy(reps,weights,**kwargs)
                else:
                    self.axes.plot(reps,weights,**kwargs)
            if self.xset==True:
                self.axes.set_xlim(self.xlo,self.xhi)
            if self.yset==True:
                self.axes.set_ylim(self.ylo,self.yhi)
            return
        return

    def scatter(self,colx,coly,cols,colc,**kwargs):
        """
        Generate a scatter plot.
        """
        if force_bytes(self.dtype)==b'table':
            if self.verbose>2:
                print('plot',colx,coly,kwargs)
            if self.canvas_flag==False:
                self.canvas()
            if self.logx==True:
                self.axes.set_xscale('log')
            if self.logy==True:
                self.axes.set_yscale('log')

            if len(colc)>0:
                if len(cols)>0:
                    self.axes.scatter(self.dset['data/'+colx],
                                 self.dset['data/'+coly],
                                 s=self.dset['data/'+cols],
                                 c=self.dset['data/'+colc],
                                 **kwargs)
                else:
                    self.axes.scatter(self.dset['data/'+colx],
                                 self.dset['data/'+coly],
                                 c=self.dset['data/'+colc],
                                 **kwargs)
            else:
                if len(cols)>0:
                    self.axes.scatter(self.dset['data/'+colx],
                                 self.dset['data/'+coly],
                                 s=self.dset['data/'+cols],
                                 **kwargs)
                else:
                    self.axes.scatter(self.dset['data/'+colx],
                                 self.dset['data/'+coly],
                                 **kwargs)
            if self.xset==True:
                self.axes.set_xlim(self.xlo,self.xhi)
            if self.yset==True:
                self.axes.set_ylim(self.ylo,self.yhi)
        return

    def plot1(self,col,**kwargs):
        """
        If the current dataset is of type ``table``, then
        plot the column specified in ``col``
        """
        if force_bytes(self.dtype)!=b'table':
            print('Wrong type',self.dtype,'for plot1.')
            return
        if self.verbose>2:
            print('plot1',col,kwargs)
        if self.canvas_flag==False:
            self.canvas()
        tlist=range(1,len(self.dset['data/'+col])+1)
        if self.logx==True:
            if self.logy==True:
                self.axes.loglog(tlist,self.dset['data/'+col],**kwargs)
            else:
                self.axes.semilogx(tlist,self.dset['data/'+col],**kwargs)
        else:
            if self.logy==True:
                self.axes.semilogy(tlist,self.dset['data/'+col],**kwargs)
            else:
                self.axes.plot(tlist,self.dset['data/'+col],**kwargs)
        if self.xset==True:
            self.axes.set_xlim(self.xlo,self.xhi)
        if self.yset==True:
            self.axes.set_ylim(self.ylo,self.yhi)
        return

    def histplot(self,col,**kwargs):
        """
        If the current dataset is of type ``hist``, then
        plot the associated histogram.
        """
        if self.verbose>2:
            print('histplot',kwargs)
        if self.canvas_flag==False:
            self.canvas()
        for key in kwargs:
            if key=='bins':
                kwargs[key]=int(kwargs[key])
        if force_bytes(self.dtype)==b'table':
            self.axes.hist(self.dset['data/'+col],**kwargs)
        else:
            print('Wrong type',self.dtype,'for histplot()')
        return

    def hist2dplot(self,colx,coly,**kwargs):
        """
        If the current dataset is of type ``hist2d``, then
        plot the associated two-dimensional histogram.
        """
        if self.verbose>2:
            print('hist2d',colx,coly,kwargs)
        if self.canvas_flag==False:
            self.canvas()
        for key in kwargs:
            if key=='bins':
                kwargs[key]=int(kwargs[key])
        self.axes.hist2d(self.dset['data/'+colx],self.dset['data/'+coly],**kwargs)
        return

    def read(self,filename):
        """
        Read first object of type ``table`` from file ``filename``
        """
        if self.verbose>0:
            print('Reading file',filename,'.')
        self.dset=self.h5r.h5read_first_type(filename,'table')
        self.dtype='table'
        return

    def read_type(self,filename,loc_type):
        """
        Read first object of type ``loc_type`` from file ``filename``
        """
        if self.verbose>0:
            print('Reading object of type',loc_type,
                  'in file',filename,'.')
        self.dset=self.h5r.h5read_first_type(filename,loc_type)
        self.dtype=loc_type
        return

    def read_name(self,filename,name):
        """
        Read object named ``name`` from file ``filename``
        """
        if self.verbose>0:
            print('Reading object named',name,'in file',filename,'.')
        atuple=self.h5r.h5read_name(filename,name)
        self.dset=atuple[0]
        self.dtype=atuple[1]
        return

    def list(self):
        """
        If the current data set is of type ``table``,
        then list the columns.
        """
        if force_bytes(self.dtype)==b'table':
            col_list=get_str_array(self.dset['col_names'])
            if self.verbose>2:
                print('-----------------------')
            unit_list=[]
            unit_flag=self.dset['unit_flag'][0]
            print('unit_flag',unit_flag)
            if self.verbose>2:
                print('unit_flag:',unit_flag)
            if unit_flag==1:
                unit_list=get_str_array(self.dset['units'])
                if self.verbose>2:
                    print('-----------------------')
                    print('unit_list:',unit_list)
            print(len(col_list),'columns.')
            for ix in range(0,len(col_list)):
                if unit_flag:
                    print(str(ix)+'. '+col_list[ix]+' ['+unit_list[ix]+']')
                else:
                    print(str(ix)+'. '+col_list[ix])
            print(self.dset['nlines'][0],'lines.')
            if self.verbose>2:
                print('Done in list')
        elif force_bytes(self.dtype)==b'table3d':
            sl_list=get_str_array(self.dset['slice_names'])
            print(len(sl_list),'slices.')
            for ix in range(0,len(sl_list)):
                print(str(ix)+'. '+sl_list[ix])
            xgrid=self.dset['xval'].value
            ygrid=self.dset['yval'].value
            lxgrid=len(xgrid)
            lygrid=len(ygrid)
            print('X-grid start: '+str(xgrid[0])+' end: '+
                  str(xgrid[lxgrid-1])+' size '+str(lxgrid))
            print('Y-grid start: '+str(ygrid[0])+' end: '+
                  str(ygrid[lygrid-1])+' size '+str(lygrid))
        else:
            print('Cannot list type',self.dtype)
        return

    def den_plot(self,slice_name,**kwargs):
        """
        If the current object is of type ``table3d``, create a density
        plot from the slice named ``slice_name`` .
        """
        if force_bytes(self.dtype)==b'table3d':
            name='data/'+slice_name
            sl=self.dset[name].value
            sl=sl.transpose()
            xgrid=self.dset['xval'].value
            ygrid=self.dset['yval'].value
            if self.canvas_flag==False:
                self.canvas()
            if self.logx==True:
                for i in range(0,len(xgrid)):
                    xgrid[i]=math.log(xgrid[i],10)
            if self.logy==True:
                for i in range(0,len(ygrid)):
                    ygrid[i]=math.log(ygrid[i],10)
            if self.logz==1:
                for i in range(0,len(xgrid)):
                    for j in range(0,len(ygrid)):
                        sl[i][j]=math.log10(sl[i][h])
            lx=len(xgrid)
            ly=len(ygrid)
            im=self.axes.imshow(sl,interpolation='nearest',
                        origin='lower',
                        extent=[xgrid[0]-(xgrid[1]-xgrid[0])/2,
                                xgrid[lx-1]+(xgrid[lx-1]-xgrid[lx-2])/2,
                                ygrid[0]-(ygrid[1]-ygrid[0])/2,
                                ygrid[ly-1]+(ygrid[ly-1]-ygrid[ly-2])/2],
                        aspect='auto',**kwargs)
            if self.colbar==True:
                cbar=self.fig.colorbar(im)
                cbar.ax.tick_params(labelsize=self.font*0.8)
                
        else:
            print('Cannot density plot object of type',self.dtype)
        return

class o2graph_plotter(plot_base):
    """
    A plotting class for the o2graph script. This class is a child of the
    :py:class:`o2sclpy.plot_base` class.

    This class is not necessarily intended to be instantiated by the 
    end user.
    """

    yt_scene=0
    """ 
    The yt scene object
    """
    yt_created_scene=False
    """
    If true, then the yt scene object has been created
    """
    yt_camera=0
    """ 
    The yt camera object
    """
    yt_created_camera=False
    """
    If true, then the yt camera object has been created
    """

    def yt_create_scene(self):
        """
        Create the yt scene object and set yt_created_scene to True
        """
        from yt.visualization.volume_rendering.api import Scene
        self.yt_scene=Scene()
        self.yt_created_scene=True
        
    def yt_create_camera(self,ds):
        """
        Create the yt camera object using the class variables
        ``yt_resolution``, ``yt_position``, and ``yt_focus``, with a
        camera width based on the domain width of ``ds``.
        """
        self.yt_camera=self.yt_scene.add_camera()
        self.yt_camera.resolution=self.yt_resolution
        self.yt_camera.width=1.5*ds.domain_width[0]
        self.yt_camera.position=self.yt_position
        self.yt_camera.focus=self.yt_focus
        self.yt_camera.north_vector=[0.0,0.0,1.0]
        self.yt_camera.switch_orientation()
        self.yt_created_camera=True
    
    def yt_text_to_points(self,veco,vecx,vecy,text,alpha=0.5,font=20,
                          show=False):
        """
        Take two 3D vectors x ('vecx' and 'vecy'), and a string of text
        ('text'), and return a numpy array of shape (6,npoints) which has
        entries (x,y,z,r,g,b). The values r, g,
        and b are between 0 and 1.
        """
        fig, axes = plot.subplots()
        plot.rc('text',usetex=True)
        axes.text(0.5,0.5,text,fontsize=font,ha='center',va='center')
        plot.axis('off')
        fig.canvas.draw()
        if show:
            plot.show()
        X=np.array(fig.canvas.renderer._renderer)
        Y=[]
        Y2=[]
        for i in range(0,480):
            for j in range(0,640):
                if X[i,j,0]!=255 or X[i,j,1]!=255 or X[i,j,2]!=255:
                    xold=(i-240)/240.0
                    yold=(j-320)/320.0
                    vecnew=[veco[0]-vecy[0]*xold+vecx[0]*yold,
                            veco[1]-vecy[1]*xold+vecx[1]*yold,
                            veco[2]-vecy[2]*xold+vecx[2]*yold]
                    Y.append([vecnew[0],vecnew[1],vecnew[2]])
                    Y2.append([1.0-X[i,j,0]/255.0,1.0-X[i,j,1]/255.0,
                               1.0-X[i,j,2]/255.0,alpha])
        return(np.array(Y),np.array(Y2))

    def yt_text_to_scene(self,loc,text,scale=0.6,
                         keyname='o2graph_text'):
        """
        At location 'loc' put text 'text' into the scene using
        specified scale parameter and keyname.
        """
        
        # Construct orientation vectors
        view_y=self.yt_camera.north_vector
        view_x=-np.cross(view_y,self.yt_camera.focus-
                         self.yt_camera.position)
        # Normalize view_x and view_y
        view_x=view_x/np.sqrt(view_x[0]**2+view_x[1]**2+view_x[2]**2)
        view_y=view_y/np.sqrt(view_y[0]**2+view_y[1]**2+view_y[2]**2)
    
        # Choose scale
        view_x=view_x*scale
        view_y=view_y*scale
        
        # Convert text to points
        (Y,Y2)=text_to_points(loc,view_x,view_y,text)
    
        # Add the point source
        points_xalabels=PointSource(Y,colors=Y2)
        yt_scene.add_source(points_xalabels,keyname=keyname)

    def yt_plot_axes(self,color=[1.0,1.0,1.0,0.5]):
        # Point at origin
        vertex_origin=np.array([[0.0,0.0,0.0]])
        color_origin=np.array([color])
        points=PointSource(vertex_origin,colors=color_origin,radii=3)
        yt_scene.add_source(points,keyname='o2graph_origin')
    
        # Create axis lines
        vertices_axis=np.array([[[0.0,0.0,0.0],[1.0,0.0,0.0]],
                                [[0.0,0.0,0.0],[0.0,1.0,0.0]],
                                [[0.0,0.0,0.0],[0.0,0.0,1.0]]])
        colors_axis=np.array([color,color,color])
        axis=LineSource(vertices_axis,colors_axis)
        yt_scene.add_source(axis,keyname='o2graph_axis_lines')
        
        # Create arrow heads
        list2=[]
        clist2=[]
        for theta in range(0,20):
            for z in range(0,10):
                xloc=1.0-z/200.0
                r=z/800.0
                yloc=r*math.cos(theta/10.0*math.pi)
                zloc=r*math.sin(theta/10.0*math.pi)
                list2.append([[1,0,0],[xloc,yloc,zloc]])
                yloc=1.0-z/200.0
                r=z/800.0
                xloc=r*math.cos(theta/10.0*math.pi)
                zloc=r*math.sin(theta/10.0*math.pi)
                list2.append([[0,1,0],[xloc,yloc,zloc]])
                zloc=1.0-z/200.0
                r=z/800.0
                xloc=r*math.cos(theta/10.0*math.pi)
                yloc=r*math.sin(theta/10.0*math.pi)
                list2.append([[0,0,1],[xloc,yloc,zloc]])
                clist2.append(color)
                clist2.append(color)
                clist2.append(color)
        points_aheads2=LineSource(np.array(list2),np.array(clist2))
        yt_scene.add_source(points_aheads2,keyname='o2graph_axis_arrows')
        
    def check_backend(self):
        """
        For yt, check that we're using the Agg backend.
        """
        import matplotlib
        if (matplotlib.get_backend()!='Agg' and 
            matplotlib.get_backend()!='agg'):
            print('yt integration only works with Agg.')
            print('Current backend is',matplotlib.get_backend())
            return
    
    def set_wrapper(self,o2scl_hdf,amp,args):
        """
        Wrapper for :py:func:`o2sclpy.plot_base.set` which sets
        plot-related parameters and sends other parameters to
        ``acol_manager``
        """

        match=False
        for line in param_list:
            if args[0]==line[0]:
                match=True
                
        for line in yt_param_list:
            if args[0]==line[0]:
                match=True
                
        if match==True:
            self.set(args[0],args[1])

        # If we're modifying the verbose parameter, then make
        # sure both the o2graph and the acol version match. Otherwise,
        # if it's only an o2graph parameter, then just return.
        if (match==True and 
            force_bytes(args[0])!=b'verbose'):
            return
        
        str_args='-set'
        size_type=ctypes.c_int * (len(args)+1)
        sizes=size_type()
        sizes[0]=len('set')+1
            
        for i in range(0,len(args)):
            str_args=str_args+args[i]
            sizes[i+1]=len(args[i])
        ccp=ctypes.c_char_p(force_bytes(str_args))
    
        parse_fn=o2scl_hdf.o2scl_acol_parse
        parse_fn.argtypes=[ctypes.c_void_p,ctypes.c_int,
                           size_type,ctypes.c_char_p]
            
        parse_fn(amp,len(args)+1,sizes,ccp)

    def get_wrapper(self,o2scl_hdf,amp,args):
        """
        Wrapper for :py:func:`o2sclpy.plot_base.get` which
        gets plot-related parameters and gets other parameters
        from ``acol_manager``
        """
        match=False
        for line in param_list:
            if args[0]==line[0]:
                match=True
        
        if match==True:
            
            self.get(args[0])
                            
        else:
                        
            str_args='-get'
            size_type=ctypes.c_int * (len(args)+1)
            sizes=size_type()
            sizes[0]=len('get')+1
        
            for i in range(0,len(args)):
                str_args=str_args+args[i]
                sizes[i+1]=len(args[i])
            ccp=ctypes.c_char_p(force_bytes(str_args))
        
            parse_fn=o2scl_hdf.o2scl_acol_parse
            parse_fn.argtypes=[ctypes.c_void_p,ctypes.c_int,
                              size_type,ctypes.c_char_p]
        
            parse_fn(amp,len(args)+1,sizes,ccp)

    def gen(self,o2scl_hdf,amp,cmd_name,args):
        """
        Run a general ``acol`` command named ``cmd_name`` with arguments
        stored in ``args``.
        """

        str_args='-'+cmd_name
        size_type=ctypes.c_int * (len(args)+1)
        sizes=size_type()
        sizes[0]=len(cmd_name)+1
        
        for i in range(0,len(args)):
            str_args=str_args+args[i]
            sizes[i+1]=len(args[i])
        ccp=ctypes.c_char_p(force_bytes(str_args))

        parse_fn=o2scl_hdf.o2scl_acol_parse
        parse_fn.argtypes=[ctypes.c_void_p,ctypes.c_int,
                           size_type,ctypes.c_char_p]
        
        parse_fn(amp,len(args)+1,sizes,ccp)

    def get_type(self,o2scl_hdf,amp):
        """
        Get the current O\ :sub:`2`\ scl object type
        """
        
        int_ptr=ctypes.POINTER(ctypes.c_int)
        char_ptr=ctypes.POINTER(ctypes.c_char)
        char_ptr_ptr=ctypes.POINTER(char_ptr)
        
        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]
        
        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]
                        
        return curr_type
        
    def den_plot(self,o2scl_hdf,amp,args):
        """
        Density plot from a ``table3d``, ``hist_2d`` ``tensor_grid``,
        ``tensor``, ``tensor<int>`` or ``tensor<size_t>`` object
        """

        int_ptr=ctypes.POINTER(ctypes.c_int)
        double_ptr=ctypes.POINTER(ctypes.c_double)
        char_ptr=ctypes.POINTER(ctypes.c_char)
        double_ptr_ptr=ctypes.POINTER(double_ptr)
        char_ptr_ptr=ctypes.POINTER(char_ptr)

        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]

        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
        kwstring=''
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]

        # Handle tensor and table3d types
        if (curr_type==b'tensor' or curr_type==b'tensor<size_t>' or
            curr_type==b'tensor_grid' or curr_type==b'tensor<int>' or
            curr_type==b'table3d'):

            # If the object is a tensor, convert to a table3d
            # object before plotting
            if curr_type!=b'table3d':
                index1=0
                index2=1
                if len(args)==1:
                    kwstring=args[0]
                if len(args)>=2:
                    index1=int(args[0])
                    index2=int(args[1])
                if len(args)>=3:
                    kwstring=args[2]
                if index1+index2!=1 and index1*index2!=0:
                    print('Indices must be "0 1" or "1 0" in',
                          'in den-plot.')
                    return
                    
                conv_fn=o2scl_hdf.o2scl_acol_tensor_to_table3d
                conv_fn.argtypes=[ctypes.c_void_p,ctypes.c_int,ctypes.c_int]
                conv_fn.restype=ctypes.c_int
                
                conv_ret=conv_fn(amp,index1,index2)
                if conv_ret!=0:
                    print('Automatic conversion to table3d failed.')
                    return
                slice_name="tensor"
            else:
                slice_name=args[0]
                if len(args)>=2:
                    kwstring=args[1]

            # Now that we are guaranteed to have a table3d
            # object to use, use that to create the density
            # plot
            get_fn=o2scl_hdf.o2scl_acol_get_slice
            get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                             int_ptr,double_ptr_ptr,
                             int_ptr,double_ptr_ptr,double_ptr_ptr]

            slice=ctypes.c_char_p(force_bytes(slice_name))
            nx=ctypes.c_int(0)
            ptrx=double_ptr()
            ny=ctypes.c_int(0)
            ptry=double_ptr()
            ptrs=double_ptr()
            get_fn(amp,slice,ctypes.byref(nx),ctypes.byref(ptrx),
                   ctypes.byref(ny),ctypes.byref(ptry),
                   ctypes.byref(ptrs))

            xgrid=[ptrx[i] for i in range(0,nx.value)]
            ygrid=[ptry[i] for i in range(0,ny.value)]
            stemp=[ptrs[i] for i in range(0,nx.value*ny.value)]
            stemp2=numpy.array(stemp)
            sl=stemp2.reshape(nx.value,ny.value)
            sl=sl.transpose()

            # If logz was specified, then manually apply the
            # log to the data. Alternatively, we should consider
            # using 'LogNorm' here, as suggested in
            
            #https://stackoverflow.com/questions/2546475/
            #how-can-i-draw-a-log-normalized-imshow-plot-
            #with-a-colorbar-representing-the-raw
            
            if self.logz==True:
                fail_found=False
                for i in range(0,ny.value):
                    for j in range(0,nx.value):
                        if sl[i][j]>0.0:
                            sl[i][j]=math.log10(sl[i][j])
                        else:
                            if fail_found==False:
                                print('Failed to take log of',sl[i][j],
                                      'at (i,j)=(',j,',',i,') or (',
                                      xgrid[j],',',ygrid[i],
                                      '). Setting point to zero and',
                                      'suppressing future warnings.')
                            fail_found=True
                            sl[i][j]=0.0
                                
            if self.logx==True:
                xgrid=[math.log(ptrx[i],10) for i in
                       range(0,nx.value)]
            if self.logy==True:
                ygrid=[math.log(ptry[i],10) for i in
                       range(0,ny.value)]

            # If the z range was specified, truncate all values
            # outside that range (this truncation is done after
            # the application of the log above)
            if self.zset==True:
                for i in range(0,ny.value):
                    for j in range(0,nx.value):
                        if sl[i][j]>self.zhi:
                            sl[i][j]=self.zhi
                        elif sl[i][j]<self.zlo:
                            sl[i][j]=self.zlo

            if self.canvas_flag==False:
                self.canvas()

            diffs_x=[xgrid[i+1]-xgrid[i] for i in range(0,len(xgrid)-1)]
            mean_x=numpy.mean(diffs_x)
            std_x=numpy.std(diffs_x)
            diffs_y=[ygrid[i+1]-ygrid[i] for i in range(0,len(ygrid)-1)]
            mean_y=numpy.mean(diffs_y)
            std_y=numpy.std(diffs_y)
            
            if std_x/mean_x>1.0e-4 or std_x/mean_x>1.0e-4:
                print('Warning in o2graph::o2graph_plotter::den_plot():')
                print('  Nonlinearity of x or y grid is greater than '+
                      '10^{-4}.')
                print('  Value of std(diff_x)/mean(diff_x): %7.6e .' %
                      (std_x/mean_x))
                print('  Value of std(diff_y)/mean(diff_y): %7.6e .' %
                      (std_y/mean_y))
                print('  The density plot may not be properly scaled.')
                
            extent1=xgrid[0]-(xgrid[1]-xgrid[0])/2
            extent2=xgrid[nx.value-1]+(xgrid[nx.value-1]-
                                       xgrid[nx.value-2])/2
            extent3=ygrid[0]-(ygrid[1]-ygrid[0])/2
            extent4=ygrid[ny.value-1]+(ygrid[ny.value-1]-
                                       ygrid[ny.value-2])/2
                        
            if len(kwstring)==0:
                im=self.axes.imshow(sl,interpolation='nearest',
                            origin='lower',extent=[extent1,extent2,
                                                   extent3,extent4],
                            aspect='auto')
            else:
                im=self.axes.imshow(sl,interpolation='nearest',
                                 origin='lower',extent=[extent1,extent2,
                                                        extent3,extent4],
                                 aspect='auto',**string_to_dict(kwstring))
                
            # The color bar is added later below...

            # End of section for tensor types and table3d
        elif curr_type==b'hist_2d':

            get_fn=o2scl_hdf.o2scl_acol_get_hist_2d
            get_fn.argtypes=[ctypes.c_void_p,int_ptr,double_ptr_ptr,
                             int_ptr,double_ptr_ptr,double_ptr_ptr]

            nx=ctypes.c_int(0)
            ptrx=double_ptr()
            ny=ctypes.c_int(0)
            ptry=double_ptr()
            ptrs=double_ptr()
            get_fn(amp,ctypes.byref(nx),ctypes.byref(ptrx),
                   ctypes.byref(ny),ctypes.byref(ptry),
                   ctypes.byref(ptrs))

            xgrid=[ptrx[i] for i in range(0,nx.value)]
            ygrid=[ptry[i] for i in range(0,ny.value)]
            stemp=[ptrs[i] for i in range(0,nx.value*ny.value)]
            stemp2=numpy.array(stemp)
            sl=stemp2.reshape(nx.value,ny.value)
            sl=sl.transpose()

            if self.logx==True:
                xgrid=[math.log(ptrx[i],10) for i in
                       range(0,nx.value)]
            if self.logy==True:
                ygrid=[math.log(ptry[i],10) for i in
                       range(0,ny.value)]

            if self.zset==True:
                for i in range(0,ny.value):
                    for j in range(0,nx.value):
                        if sl[i][j]>self.zhi:
                            sl[i][j]=self.zhi
                        elif sl[i][j]<self.zlo:
                            sl[i][j]=self.zlo
                            
            if self.logz==True:
                for i in range(0,ny.value):
                    for j in range(0,nx.value):
                        sl[i][j]=math.log10(sl[i][j])
                        
            if self.canvas_flag==False:
                self.canvas()

            extent1=xgrid[0]-(xgrid[1]-xgrid[0])/2
            extent2=xgrid[nx.value-1]+(xgrid[nx.value-1]-
                                       xgrid[nx.value-2])/2
            extent3=ygrid[0]-(ygrid[1]-ygrid[0])/2
            extent4=ygrid[ny.value-1]+(ygrid[ny.value-1]-
                                       ygrid[ny.value-2])/2
                        
            if len(args)<1:
                im=self.axes.imshow(sl,interpolation='nearest',
                            origin='lower',extent=[extent1,extent2,
                                                   extent3,extent4],
                            aspect='auto')
            else:
                im=self.axes.imshow(sl,interpolation='nearest',
                            origin='lower',extent=[extent1,extent2,
                                                   extent3,extent4],
                            aspect='auto',**string_to_dict(args[0]))

            # The color bar is added later below...

            # End of section for type hist_2d
        else:
            print("Command 'den-plot' not supported for type",
                  curr_type,".")
            return

        if self.colbar==True:
            cbar=self.fig.colorbar(im)
            cbar.ax.tick_params(labelsize=self.font*0.8)

    def plot(self,o2scl_hdf,amp,args):
        """
        Plot a two-dimensional set of data
        """

        # Useful pointer types
        double_ptr=ctypes.POINTER(ctypes.c_double)
        char_ptr=ctypes.POINTER(ctypes.c_char)
        double_ptr_ptr=ctypes.POINTER(double_ptr)
        char_ptr_ptr=ctypes.POINTER(char_ptr)
        int_ptr=ctypes.POINTER(ctypes.c_int)
        
        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]

        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]
                        
        if curr_type==b'table':
                            
            failed=False

            get_fn=o2scl_hdf.o2scl_acol_get_column
            get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                             int_ptr,double_ptr_ptr]
            get_fn.restype=ctypes.c_int

            colx=ctypes.c_char_p(force_bytes(args[0]))
            idx=ctypes.c_int(0)
            ptrx=double_ptr()
            get_ret=get_fn(amp,colx,ctypes.byref(idx),ctypes.byref(ptrx))
            if get_ret!=0:
                print('Failed to get column named "'+args[0]+'".')
                failed=True

            coly=ctypes.c_char_p(force_bytes(args[1]))
            idy=ctypes.c_int(0)
            ptry=double_ptr()
            get_ret=get_fn(amp,coly,ctypes.byref(idy),ctypes.byref(ptry))
            if get_ret!=0:
                print('Failed to get column named "'+args[1]+'".')
                failed=True

            if failed==False:
                xv=[ptrx[i] for i in range(0,idx.value)]
                yv=[ptry[i] for i in range(0,idy.value)]
        
                if self.canvas_flag==False:
                    self.canvas()
                if self.logx==True:
                    if self.logy==True:
                        if len(args)<3:
                            self.axes.loglog(xv,yv)
                        else:
                            self.axes.loglog(xv,yv,**string_to_dict(args[2]))
                    else:
                        if len(args)<3:
                            self.axes.semilogx(xv,yv)
                        else:
                            self.axes.semilogx(xv,yv,**string_to_dict(args[2]))
                else:
                    if self.logy==True:
                        if len(args)<3:
                            self.axes.semilogy(xv,yv)
                        else:
                            self.axes.semilogy(xv,yv,**string_to_dict(args[2]))
                    else:
                        if len(args)<3:
                            self.axes.plot(xv,yv)
                        else:
                            self.axes.plot(xv,yv,**string_to_dict(args[2]))

            # End of section for 'table' type
        elif curr_type==b'hist':

            get_reps_fn=o2scl_hdf.o2scl_acol_get_hist_reps
            get_reps_fn.argtypes=[ctypes.c_void_p,
                             int_ptr,double_ptr_ptr]
                            
            get_wgts_fn=o2scl_hdf.o2scl_acol_get_hist_wgts
            get_wgts_fn.argtypes=[ctypes.c_void_p,
                             int_ptr,double_ptr_ptr]
                            
            idx=ctypes.c_int(0)
            ptrx=double_ptr()
            get_reps_fn(amp,ctypes.byref(idx),
                        ctypes.byref(ptrx))

            idy=ctypes.c_int(0)
            ptry=double_ptr()
            get_wgts_fn(amp,ctypes.byref(idy),
                        ctypes.byref(ptry))

            xv=[ptrx[i] for i in range(0,idx.value)]
            yv=[ptry[i] for i in range(0,idy.value)]
    
            if self.canvas_flag==False:
                self.canvas()
            if self.logx==True:
                if self.logy==True:
                    if len(args)<1:
                        self.axes.loglog(xv,yv)
                    else:
                        self.axes.loglog(xv,yv,**string_to_dict(args[0]))
                else:
                    if len(args)<1:
                        self.axes.semilogx(xv,yv)
                    else:
                        self.axes.semilogx(xv,yv,**string_to_dict(args[0]))
            else:
                if self.logy==True:
                    if len(args)<1:
                        self.axes.semilogy(xv,yv)
                    else:
                        self.axes.semilogy(xv,yv,**string_to_dict(args[0]))
                else:
                    if len(args)<1:
                        self.axes.plot(xv,yv)
                    else:
                        self.axes.plot(xv,yv,**string_to_dict(args[0]))
                            
            # End of section for 'hist' type
        elif curr_type==b'prob_dens_mdim_amr':

            get_base_fn=o2scl_hdf.o2scl_acol_pdma_get_base
            get_base_fn.argtypes=[ctypes.c_void_p,int_ptr,
                                  int_ptr,double_ptr_ptr,double_ptr_ptr]
                            
            get_cube_fn=o2scl_hdf.o2scl_acol_pdma_get_cube
            get_cube_fn.argtypes=[ctypes.c_void_p,ctypes.c_int,
                                  double_ptr_ptr,double_ptr_ptr,
                                  double_ptr,double_ptr]
                            
            ndimx=ctypes.c_int(0)
            nx=ctypes.c_int(0)
            lowx=double_ptr()
            highx=double_ptr()
            get_base_fn(amp,ctypes.byref(ndimx),ctypes.byref(nx),
                        ctypes.byref(lowx),ctypes.byref(highx))

            dimx=int(args[0])
            dimy=int(args[1])

            self.xlo=lowx[dimx]
            self.ylo=lowx[dimy]
            self.xset=True
            self.xhi=highx[dimx]
            self.yhi=highx[dimy]
            self.yset=True

            if self.canvas_flag==False:
                self.canvas()

            # Need to figure out here how to convert fill function
            # to a value, keeping in mind it can depend on
            # fvy.value (fractional volume) or wy.value (weight)
                
            fill_fn='None'
            if len(args)>=3:
                fill_fn=args[2]
                
            print('Fill function',fill_fn)
                
            for i in range(0,nx.value):

                iy=ctypes.c_int(i)
                lowy=double_ptr()
                highy=double_ptr()
                fvy=ctypes.c_double(0.0)
                wy=ctypes.c_double(0.0)
                get_cube_fn(amp,iy,ctypes.byref(lowy),
                            ctypes.byref(highy),
                            ctypes.byref(fvy),
                            ctypes.byref(wy))
                
                left=lowy[dimx]
                lower=lowy[dimy]
                right=highy[dimx]
                upper=highy[dimy]
                w=right-left
                h=upper-lower

                if len(args)<4:
                    r=patches.Rectangle((left,lower),w,h,0.0,
                                        alpha=fvy.value)
                    self.axes.add_patch(r)
                else:
                    strtemp='alpha='+str(fvy.value)+','+args[3]
                    r=patches.Rectangle((left,lower),w,h,0.0,
                                        **string_to_dict(strtemp))
                    self.axes.add_patch(r)
                            
            # End of section for 'prob_dens_mdim_amr' type
        elif curr_type==b'vector<contour_line>':

            # Get the total number of contour lines
            cont_n_fn=o2scl_hdf.o2scl_acol_contours_n
            cont_n_fn.argtypes=[ctypes.c_void_p]
            cont_n_fn.restype=ctypes.c_int
            nconts=cont_n_fn(amp)

            # Define types for extracting each contour line
            cont_line_fn=o2scl_hdf.o2scl_acol_contours_line
            cont_line_fn.argtypes=[ctypes.c_void_p,ctypes.c_int,
                                   int_ptr,double_ptr_ptr,
                                   double_ptr_ptr]
            cont_line_fn.restype=ctypes.c_double

            if self.canvas_flag==False:
                self.canvas()

            # Loop over all contour lines
            for k in range(0,nconts):
                idx=ctypes.c_int(0)
                ptrx=double_ptr()
                ptry=double_ptr()
                lev=cont_line_fn(amp,k,ctypes.byref(idx),
                                 ctypes.byref(ptrx),ctypes.byref(ptry))
                xv=[ptrx[i] for i in range(0,idx.value)]
                yv=[ptry[i] for i in range(0,idx.value)]
                
                if self.logx==True:
                    if self.logy==True:
                        if len(args)<1:
                            self.axes.loglog(xv,yv)
                        else:
                            self.axes.loglog(xv,yv,**string_to_dict(args[0]))
                    else:
                        if len(args)<1:
                            self.axes.semilogx(xv,yv)
                        else:
                            self.axes.semilogx(xv,yv,**string_to_dict(args[0]))
                else:
                    if self.logy==True:
                        if len(args)<1:
                            self.axes.semilogy(xv,yv)
                        else:
                            self.axes.semilogy(xv,yv,**string_to_dict(args[0]))
                    else:
                        if len(args)<1:
                            self.axes.plot(xv,yv)
                        else:
                            self.axes.plot(xv,yv,**string_to_dict(args[0]))
            # End of section for 'vector<contour_line>' type
        else:
            print("Command 'plot' not supported for type",
                  curr_type,".")
            return
        
        if self.xset==True:
            self.axes.set_xlim(self.xlo,self.xhi)
        if self.yset==True:
            self.axes.set_ylim(self.ylo,self.yhi)
                                 
        # End of 'plot' function
                                 
    def rplot(self,o2scl_hdf,amp,args):
        """
        Plot a region inside a curve or in between two curves
        """

        # Useful pointer types
        double_ptr=ctypes.POINTER(ctypes.c_double)
        char_ptr=ctypes.POINTER(ctypes.c_char)
        double_ptr_ptr=ctypes.POINTER(double_ptr)
        char_ptr_ptr=ctypes.POINTER(char_ptr)
        int_ptr=ctypes.POINTER(ctypes.c_int)
        
        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]

        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]
                        
        if curr_type==b'table':
                            
            failed=False

            get_fn=o2scl_hdf.o2scl_acol_get_column
            get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                             int_ptr,double_ptr_ptr]
            get_fn.restype=ctypes.c_int

            colx1=ctypes.c_char_p(force_bytes(args[0]))
            idx1=ctypes.c_int(0)
            ptrx1=double_ptr()
            get_ret=get_fn(amp,colx1,ctypes.byref(idx1),ctypes.byref(ptrx1))
            if get_ret!=0:
                print('Failed to get column named "'+args[0]+'".')
                failed=True

            coly1=ctypes.c_char_p(force_bytes(args[1]))
            idy1=ctypes.c_int(0)
            ptry1=double_ptr()
            get_ret=get_fn(amp,coly1,ctypes.byref(idy1),ctypes.byref(ptry1))
            if get_ret!=0:
                print('Failed to get column named "'+args[1]+'".')
                failed=True

            if failed==False:
                xv=[ptrx1[i] for i in range(0,idx1.value)]
                yv=[ptry1[i] for i in range(0,idy1.value)]
                
            if len(args)>3:
                colx2=ctypes.c_char_p(force_bytes(args[2]))
                idx2=ctypes.c_int(0)
                ptrx2=double_ptr()
                get_ret=get_fn(amp,colx2,ctypes.byref(idx2),ctypes.byref(ptrx2))
                if get_ret!=0:
                    print('Failed to get column named "'+args[2]+'".')
                    failed=True

                coly2=ctypes.c_char_p(force_bytes(args[3]))
                idy2=ctypes.c_int(0)
                ptry2=double_ptr()
                get_ret=get_fn(amp,coly2,ctypes.byref(idy2),ctypes.byref(ptry2))
                if get_ret!=0:
                    print('Failed to get column named "'+args[3]+'".')
                    failed=True

                if failed==False:
                    for i in range(0,idx2.value):
                        xv.append(ptrx2[idx2.value-1-i])
                        yv.append(ptry2[idy2.value-1-i])

            if failed==False:
                # Make sure the loop is closed
                xv.append(ptrx1[0])
                yv.append(ptry1[0])
        
                if self.canvas_flag==False:
                    self.canvas()
                if len(args)==3:
                    self.axes.fill(xv,yv,**string_to_dict(args[2]))
                elif len(args)==5:
                    self.axes.fill(xv,yv,**string_to_dict(args[4]))
                else:
                    self.axes.fill(xv,yv)

                if self.logx==True:
                    self.axes.set_xscale('log')
                if self.logy==True:
                    self.axes.set_yscale('log')
                    
                if self.xset==True:
                    self.axes.set_xlim(self.xlo,self.xhi)
                if self.yset==True:
                    self.axes.set_ylim(self.ylo,self.yhi)
                                 
            # End of section for 'table' type
        else:
            print("Command 'rplot' not supported for type",
                  curr_type,".")
            return
        
        # End of 'rplot' function
                                 
    def scatter(self,o2scl_hdf,amp,args):
        """
        Generate a scatter plot.
        """

        # Useful pointer types
        double_ptr=ctypes.POINTER(ctypes.c_double)
        char_ptr=ctypes.POINTER(ctypes.c_char)
        double_ptr_ptr=ctypes.POINTER(double_ptr)
        char_ptr_ptr=ctypes.POINTER(char_ptr)
        int_ptr=ctypes.POINTER(ctypes.c_int)
        
        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]

        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]
                        
        if curr_type==b'table':
                            
            failed=False

            get_fn=o2scl_hdf.o2scl_acol_get_column
            get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                             int_ptr,double_ptr_ptr]
            get_fn.restype=ctypes.c_int

            colx=ctypes.c_char_p(force_bytes(args[0]))
            idx=ctypes.c_int(0)
            ptrx=double_ptr()
            get_ret=get_fn(amp,colx,ctypes.byref(idx),ctypes.byref(ptrx))
            if get_ret!=0:
                print('Failed to get column named "'+args[0]+'".')
                failed=True

            coly=ctypes.c_char_p(force_bytes(args[1]))
            idy=ctypes.c_int(0)
            ptry=double_ptr()
            get_ret=get_fn(amp,coly,ctypes.byref(idy),ctypes.byref(ptry))
            if get_ret!=0:
                print('Failed to get column named "'+args[1]+'".')
                failed=True

            if failed==False:
                xv=[ptrx[i] for i in range(0,idx.value)]
                yv=[ptry[i] for i in range(0,idy.value)]

            sv=[]
            cv=[]

            if (len(args)>2 and force_bytes(args[2])!=b'None' and
                force_bytes(args[2])!=b'none'):
                cols=ctypes.c_char_p(force_bytes(args[2]))
                ids=ctypes.c_int(0)
                ptrs=double_ptr()
                get_ret=get_fn(amp,cols,ctypes.byref(ids),ctypes.byref(ptrs))
                if get_ret!=0:
                    print('Failed to get column named "'+args[2]+'".')
                    failed=True
                else:
                    sv=[ptrs[i] for i in range(0,ids.value)]

            if (len(args)>3 and force_bytes(args[3])!=b'None' and
                force_bytes(args[3])!=b'none'):
                colc=ctypes.c_char_p(force_bytes(args[3]))
                idc=ctypes.c_int(0)
                ptrc=double_ptr()
                get_ret=get_fn(amp,colc,ctypes.byref(idc),ctypes.byref(ptrc))
                if get_ret!=0:
                    print('Failed to get column named "'+args[3]+'".')
                    failed=True
                else:
                    cv=[ptrc[i] for i in range(0,idc.value)]

            if failed==False:
                
                if self.canvas_flag==False:
                    self.canvas()
                if len(sv)>0:
                    if len(cv)>0:
                        if len(args)>4:
                            self.axes.scatter(xv,yv,s=sv,c=cv,
                                         **string_to_dict(args[4]))
                        else:
                            self.axes.scatter(xv,yv,s=sv,c=cv)
                    else:
                        if len(args)>4:
                            self.axes.scatter(xv,yv,s=sv,
                                         **string_to_dict(args[4]))
                        else:
                            self.axes.scatter(xv,yv,s=sv)
                else:
                    if len(cv)>0:
                        if len(args)>4:
                            self.axes.scatter(xv,yv,c=cv,
                                         **string_to_dict(args[4]))
                        else:
                            self.axes.scatter(xv,yv,c=cv)
                    else:
                        if len(args)>4:
                            self.axes.scatter(xv,yv,**string_to_dict(args[4]))
                        else:
                            self.axes.scatter(xv,yv)

                if self.logx==True:
                    self.axes.set_xscale('log')
                if self.logy==True:
                    self.axes.set_yscale('log')
                    
                if self.xset==True:
                    self.axes.set_xlim(self.xlo,self.xhi)
                if self.yset==True:
                    self.axes.set_ylim(self.ylo,self.yhi)
                if self.colbar==True and len(cv)>0:
                    cbar=plot.colorbar()
                    cbar.ax.tick_params(labelsize=self.font*0.8)
                    
            # End of section for 'table' type
        else:
            print("Command 'scatter' not supported for type",
                  curr_type,".")
            return
        
        if self.xset==True:
            self.axes.set_xlim(self.xlo,self.xhi)
        if self.yset==True:
            self.axes.set_ylim(self.ylo,self.yhi)
                                 
        # End of 'scatter' function
                                 
    def histplot(self,o2scl_hdf,amp,args):
        """
        Plot a histogram
        """

        # Useful pointer types
        double_ptr=ctypes.POINTER(ctypes.c_double)
        char_ptr=ctypes.POINTER(ctypes.c_char)
        double_ptr_ptr=ctypes.POINTER(double_ptr)
        char_ptr_ptr=ctypes.POINTER(char_ptr)
        int_ptr=ctypes.POINTER(ctypes.c_int)
        
        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]

        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]
                        
        if curr_type==b'table':
                            
            get_fn=o2scl_hdf.o2scl_acol_get_column
            get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                             int_ptr,double_ptr_ptr]
            get_fn.restype=ctypes.c_int

            colx=ctypes.c_char_p(force_bytes(args[0]))
            idx=ctypes.c_int(0)
            ptrx=double_ptr()
            get_ret=get_fn(amp,colx,ctypes.byref(idx),ctypes.byref(ptrx))
            failed=False
            if get_ret!=0:
                print('Failed to get column named "'+args[0]+'".')
                failed=True

            if failed==False:
                xv=[ptrx[i] for i in range(0,idx.value)]
        
                if self.canvas_flag==False:
                    self.canvas()
                if len(args)<2:
                    self.axes.hist(xv)
                else:
                    self.axes.hist(xv,**string_to_dict(args[1]))
                
            # End of section for 'table' type
        else:
            print("Command 'histplot' not supported for type",
                  curr_type,".")
            return
        
        if self.xset==True:
            self.axes.set_xlim(self.xlo,self.xhi)
        if self.yset==True:
            self.axes.set_ylim(self.ylo,self.yhi)
                                 
        # End of 'histplot' function
                                 
    def hist2dplot(self,o2scl_hdf,amp,args):
        """
        Plot a two-dimensional histogram
        """

        # Useful pointer types
        double_ptr=ctypes.POINTER(ctypes.c_double)
        char_ptr=ctypes.POINTER(ctypes.c_char)
        double_ptr_ptr=ctypes.POINTER(double_ptr)
        char_ptr_ptr=ctypes.POINTER(char_ptr)
        int_ptr=ctypes.POINTER(ctypes.c_int)
        
        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]

        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]
                        
        if curr_type==b'table':
                            
            get_fn=o2scl_hdf.o2scl_acol_get_column
            get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                             int_ptr,double_ptr_ptr]
            get_fn.restype=ctypes.c_int

            failed=False

            colx=ctypes.c_char_p(force_bytes(args[0]))
            idx=ctypes.c_int(0)
            ptrx=double_ptr()
            get_ret=get_fn(amp,colx,ctypes.byref(idx),ctypes.byref(ptrx))
            if get_ret!=0:
                print('Failed to get column named "'+args[0]+'".')
                failed=True
            
            coly=ctypes.c_char_p(force_bytes(args[1]))
            idy=ctypes.c_int(0)
            ptry=double_ptr()
            get_ret=get_fn(amp,coly,ctypes.byref(idy),ctypes.byref(ptry))
            if get_ret!=0:
                print('Failed to get column named "'+args[1]+'".')
                failed=True

            if failed==False:
                xv=[ptrx[i] for i in range(0,idx.value)]
                yv=[ptry[i] for i in range(0,idy.value)]
        
                if self.canvas_flag==False:
                    self.canvas()
                if len(args)<3:
                    self.axes.hist2d(xv,yv)
                else:
                    self.axes.hist2d(xv,yv,**string_to_dict(args[2]))
                
                if self.colbar==True:
                    cbar=plot.colorbar()
                    cbar.ax.tick_params(labelsize=self.font*0.8)
                    
            # End of section for 'table' type
        else:
            print("Command 'plot' not supported for type",
                  curr_type,".")
            return
        
        if self.xset==True:
            self.axes.set_xlim(self.xlo,self.xhi)
        if self.yset==True:
            self.axes.set_ylim(self.ylo,self.yhi)
                                 
        # End of 'plot' function
                                 
    def errorbar(self,o2scl_hdf,amp,args):
        """
        Create a plot with error bars
        """

        # Useful pointer types
        double_ptr=ctypes.POINTER(ctypes.c_double)
        char_ptr=ctypes.POINTER(ctypes.c_char)
        double_ptr_ptr=ctypes.POINTER(double_ptr)
        char_ptr_ptr=ctypes.POINTER(char_ptr)
        int_ptr=ctypes.POINTER(ctypes.c_int)
        
        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]

        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]
                        
        if curr_type==b'table':
                            
            get_fn=o2scl_hdf.o2scl_acol_get_column
            get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                             int_ptr,double_ptr_ptr]

            colx=ctypes.c_char_p(force_bytes(args[0]))
            idx=ctypes.c_int(0)
            ptrx=double_ptr()
            get_fn(amp,colx,ctypes.byref(idx),ctypes.byref(ptrx))
            xv=[ptrx[i] for i in range(0,idx.value)]

            coly=ctypes.c_char_p(force_bytes(args[1]))
            idy=ctypes.c_int(0)
            ptry=double_ptr()
            get_fn(amp,coly,ctypes.byref(idy),ctypes.byref(ptry))
            yv=[ptry[i] for i in range(0,idy.value)]

            if args[2]=='0':
                xerrv=[0.0 for i in range(0,idx.value)]
            else:
                colxerr=ctypes.c_char_p(force_bytes(args[2]))
                idxerr=ctypes.c_int(0)
                ptrxerr=double_ptr()
                get_fn(amp,colxerr,ctypes.byref(idxerr),ctypes.byref(ptrxerr))
                xerrv=[ptrxerr[i] for i in range(0,idxerr.value)]
    
            if args[3]=='0':
                yerrv=[0.0 for i in range(0,idy.value)]
            else:
                colyerr=ctypes.c_char_p(force_bytes(args[3]))
                idyerr=ctypes.c_int(0)
                ptryerr=double_ptr()
                get_fn(amp,colyerr,ctypes.byref(idyerr),ctypes.byref(ptryerr))
                yerrv=[ptryerr[i] for i in range(0,idyerr.value)]

            if self.canvas_flag==False:
                self.canvas()
            if len(args)<5:
                self.axes.errorbar(xv,yv,yerr=yerrv,xerr=xerrv)
            else:
                self.axes.errorbar(xv,yv,yerr=yerrv,xerr=xerrv,
                                   **string_to_dict(args[4]))
                
            # End of section for 'table' type
        else:
            print("Command 'plot' not supported for type",
                  curr_type,".")
            return
        
        if self.xset==True:
            self.axes.set_xlim(self.xlo,self.xhi)
        if self.yset==True:
            self.axes.set_ylim(self.ylo,self.yhi)
                                 
        # End of 'errorbar' function
                                 
    def plot1(self,o2scl_hdf,amp,args):
        """
        Plot data versus an integer x axis
        """

        int_ptr=ctypes.POINTER(ctypes.c_int)
        double_ptr=ctypes.POINTER(ctypes.c_double)
        char_ptr=ctypes.POINTER(ctypes.c_char)
        double_ptr_ptr=ctypes.POINTER(double_ptr)
        char_ptr_ptr=ctypes.POINTER(char_ptr)
        
        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]

        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]
                        
        if curr_type==b'table':
            
            get_fn=o2scl_hdf.o2scl_acol_get_column
            get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                             int_ptr,double_ptr_ptr]
            get_fn.restype=ctypes.c_int

            colx=ctypes.c_char_p(force_bytes(args[0]))
            idx=ctypes.c_int(0)
            ptrx=double_ptr()
            get_ret=get_fn(amp,colx,ctypes.byref(idx),ctypes.byref(ptrx))
            failed=False
            if get_ret!=0:
                print('Failed to get column named "'+args[0]+'".')
                failed=True

            if failed==False:
                xv=[i for i in range(0,idx.value)]
                yv=[ptrx[i] for i in range(0,idx.value)]
        
                if self.canvas_flag==False:
                    self.canvas()
                if self.logx==True:
                    if self.logy==True:
                        if len(args)<2:
                            self.axes.loglog(xv,yv)
                        else:
                            self.axes.loglog(xv,yv,**string_to_dict(args[1]))
                    else:
                        if len(args)<2:
                            self.axes.semilogx(xv,yv)
                        else:
                            self.axes.semilogx(xv,yv,**string_to_dict(args[1]))
                else:
                    if self.logy==True:
                        if len(args)<2:
                            self.axes.semilogy(xv,yv)
                        else:
                            self.axes.semilogy(xv,yv,**string_to_dict(args[1]))
                    else:
                        if len(args)<2:
                            self.axes.plot(xv,yv)
                        else:
                            self.axes.plot(xv,yv,**string_to_dict(args[1]))
                                
                if self.xset==True:
                    self.axes.set_xlim(self.xlo,self.xhi)
                if self.yset==True:
                    self.axes.set_ylim(self.ylo,self.yhi)
                    
        elif (curr_type==b'double[]' or curr_type==b'int[]' or
              curr_type==b'size_t[]'):

            get_fn=o2scl_hdf.o2scl_acol_get_double_arr
            get_fn.argtypes=[ctypes.c_void_p,int_ptr,double_ptr_ptr]
                            
            id=ctypes.c_int(0)
            ptr=double_ptr()
            get_fn(amp,ctypes.byref(id),ctypes.byref(ptr))
            
            xv=[i for i in range(0,id.value)]
            yv=[ptr[i] for i in range(0,id.value)]

            if self.canvas_flag==False:
                self.canvas()
            if self.logx==True:
                if self.logy==True:
                    if len(args)<1:
                        self.axes.loglog(xv,yv)
                    else:
                        self.axes.loglog(xv,yv,**string_to_dict(args[0]))
                else:
                    if len(args)<1:
                        self.axes.semilogx(xv,yv)
                    else:
                        self.axes.semilogx(xv,yv,**string_to_dict(args[0]))
            else:
                if self.logy==True:
                    if len(args)<1:
                        self.axes.semilogy(xv,yv)
                    else:
                        self.axes.semilogy(xv,yv,**string_to_dict(args[0]))
                else:
                    if len(args)<1:
                        self.axes.plot(xv,yv)
                    else:
                        self.axes.plot(xv,yv,**string_to_dict(args[0]))
                            
            if self.xset==True:
                self.axes.set_xlim(self.xlo,self.xhi)
            if self.yset==True:
                self.axes.set_ylim(self.ylo,self.yhi)
                    
        # End of 'plot1' function
            
    def plotv(self,o2scl_hdf,amp,args):
        """
        Plot two multiple vector specifications
        """

        char_ptr=ctypes.POINTER(ctypes.c_char)
        char_ptr_ptr=ctypes.POINTER(char_ptr)
        double_ptr=ctypes.POINTER(ctypes.c_double)
        double_ptr_ptr=ctypes.POINTER(double_ptr)
        int_ptr=ctypes.POINTER(ctypes.c_int)
        
        # Set up wrapper for type function
        type_fn=o2scl_hdf.o2scl_acol_get_type
        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]
        
        # Get current type
        it=ctypes.c_int(0)
        type_ptr=char_ptr()
        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
        curr_type=b''
        for i in range(0,it.value):
            curr_type=curr_type+type_ptr[i]

        if curr_type==b'vector<contour_line>':
             print('Store and clear the vector<contour_line> object '+
                   'before using \'plotv\'.')
             return 1
        
        conv_fn=o2scl_hdf.o2scl_acol_mult_vectors_to_conts
        conv_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                          ctypes.c_char_p]
        conv_fn.restype=ctypes.c_int

        if len(args)>=2:
            if self.verbose>1:
                print('Calling mult_vectors_to_conts() with',
                      args[0],'and',args[1])
            mvs1=ctypes.c_char_p(force_bytes(args[0]))
            mvs2=ctypes.c_char_p(force_bytes(args[1]))
            conv_ret=conv_fn(amp,mvs1,mvs2)
            if conv_ret!=0:
                print('Failed to read "'+args[0]+'" and "'+args[1]+'".')
                return 2
        else:
            if self.verbose>1:
                print('Calling mult_vectors_to_conts() with',
                      args[0])
            mvs1=ctypes.c_char_p(0)
            mvs2=ctypes.c_char_p(force_bytes(args[0]))
            conv_ret=conv_fn(amp,mvs1,mvs2)
            if conv_ret!=0:
                print('Failed to read "'+args[0])
                return 2
        
        
        # Get the total number of contour lines
        cont_n_fn=o2scl_hdf.o2scl_acol_contours_n
        cont_n_fn.argtypes=[ctypes.c_void_p]
        cont_n_fn.restype=ctypes.c_int
        nconts=cont_n_fn(amp)

        # Define types for extracting each contour line
        cont_line_fn=o2scl_hdf.o2scl_acol_contours_line
        cont_line_fn.argtypes=[ctypes.c_void_p,ctypes.c_int,
                               int_ptr,double_ptr_ptr,
                               double_ptr_ptr]
        cont_line_fn.restype=ctypes.c_double

        if self.canvas_flag==False:
            self.canvas()

        # Loop over all contour lines
        for k in range(0,nconts):
            idx=ctypes.c_int(0)
            ptrx=double_ptr()
            ptry=double_ptr()
            lev=cont_line_fn(amp,k,ctypes.byref(idx),
                             ctypes.byref(ptrx),ctypes.byref(ptry))
            xv=[ptrx[i] for i in range(0,idx.value)]
            yv=[ptry[i] for i in range(0,idx.value)]
                
            if self.logx==True:
                if self.logy==True:
                    if len(args)<3:
                        self.axes.loglog(xv,yv)
                    else:
                        self.axes.loglog(xv,yv,**string_to_dict(args[2]))
                else:
                    if len(args)<3:
                        self.axes.semilogx(xv,yv)
                    else:
                        self.axes.semilogx(xv,yv,**string_to_dict(args[2]))
            else:
                if self.logy==True:
                    if len(args)<3:
                        self.axes.semilogy(xv,yv)
                    else:
                        self.axes.semilogy(xv,yv,**string_to_dict(args[2]))
                else:
                    if len(args)<3:
                        self.axes.plot(xv,yv)
                    else:
                        self.axes.plot(xv,yv,**string_to_dict(args[2]))
                        
        # End of 'plotv' function
        
    def print_param_docs(self):
        """
        Print parameter documentation.
        """
        
        # I don't know why this doesn't work right now
        # print(plot_base.logz.__doc__)
        
        print('O2graph parameter list:')
        print(' ')
        for line in param_list:
            if line[0]!='verbose':
                if line[0]=='colbar':
                    print(line[0]+' '+str(self.colbar))
                elif line[0]=='fig-dict':
                    print(line[0]+' '+str(self.fig_dict))
                elif line[0]=='font':
                    print(line[0]+' '+str(self.font))
                elif line[0]=='logx':
                    print(line[0]+' '+str(self.logx))
                elif line[0]=='logy':
                    print(line[0]+' '+str(self.logy))
                elif line[0]=='logz':
                    print(line[0]+' '+str(self.logz))
                elif line[0]=='xhi':
                    print(line[0]+' '+str(self.xhi))
                elif line[0]=='xlo':
                    print(line[0]+' '+str(self.xlo))
                elif line[0]=='xset':
                    print(line[0]+' '+str(self.xset))
                elif line[0]=='xtitle':
                    print(line[0]+' '+str(self.xtitle))
                elif line[0]=='yhi':
                    print(line[0]+' '+str(self.yhi))
                elif line[0]=='ylo':
                    print(line[0]+' '+str(self.ylo))
                elif line[0]=='yset':
                    print(line[0]+' '+str(self.yset))
                elif line[0]=='ytitle':
                    print(line[0]+' '+str(self.ytitle))
                elif line[0]=='ztitle':
                    print(line[0]+' '+str(self.ztitle))
                elif line[0]=='zhi':
                    print(line[0]+' '+str(self.zhi))
                elif line[0]=='zlo':
                    print(line[0]+' '+str(self.zlo))
                elif line[0]=='zset':
                    print(line[0]+' '+str(self.zset))
                else:
                    print(line[0])
                print(' '+line[1])
                print(' ')
        print('yt-related settings:')
        print(' ')
        for line in yt_param_list:
            if line[0]=='yt-axis-color':
                print(line[0]+' '+str(self.yt_axis_color))
            if line[0]=='yt-axis-labels-flat':
                print(line[0]+' '+str(self.yt_axis_labels_flat))
            if line[0]=='yt-resolution':
                print(line[0]+' '+str(self.yt_resolution))
            if line[0]=='yt-position':
                print(line[0]+' '+str(self.yt_position))
            if line[0]=='yt-path':
                print(line[0]+' '+str(self.yt_path))
            if line[0]=='yt-focus':
                print(line[0]+' '+str(self.yt_focus))
            print(' '+line[1])
            print(' ')
        
    def parse_argv(self,argv,o2scl_hdf):
        """
        Parse command-line arguments.

        This is the main function used by the 
        :ref:`O2graph script`
        """

        # Create an acol_manager object and get the pointer
        o2scl_hdf.o2scl_create_acol_manager.restype=ctypes.c_void_p
        amp=o2scl_hdf.o2scl_create_acol_manager()

        names_fn=o2scl_hdf.o2scl_acol_set_names
        names_fn.argtypes=[ctypes.c_void_p,ctypes.c_int,ctypes.c_char_p,
                           ctypes.c_int,ctypes.c_char_p,ctypes.c_int,
                           ctypes.c_char_p]

        # Get current type
        cmd_name=b'o2graph'
        cmd_desc=(b'o2graph: A data viewing and '+
                  b'processing program for O2scl.\n')
        env_var=b'O2GRAPH_DEFAULTS'
        names_fn(amp,len(cmd_name),ctypes.c_char_p(cmd_name),
                 len(cmd_desc),ctypes.c_char_p(cmd_desc),
                 len(env_var),ctypes.c_char_p(env_var))
        
        if len(argv)<=1:
            done_flag=False
            readline.parse_and_bind('tab: complete')
            readline.parse_and_bind('set editing-mode emacs')
            while done_flag==False:
                line=input('o2graph> ')
                if line[0:4]=='quit' or line[0:4]=='exit':
                    done_flag=True
                else:
                    strlist=line.split(' ')
                    strlist[0]='-'+strlist[0]
                    self.parse_string_list(strlist,o2scl_hdf,amp)
        else:
            strlist=[str(argv[i]) for i in range(1,len(argv))]
            if self.verbose>2:
                print('Number of arguments:',len(strlist),'arguments.')
                print('Argument List:',strlist)
            self.parse_string_list(strlist,o2scl_hdf,amp)

        # End of function parse_argv
        return
            
    def parse_string_list(self,strlist,o2scl_hdf,amp):
        """
        Parse a list of strings

        This function is called by parse_argv().
        """
        if self.verbose>2:
            print('In parse_string_list()',strlist)
        
        ix=0
        while ix<len(strlist):
            
            if self.verbose>2:
                print('Processing index',ix,'with value',strlist[ix],'.')
            # Find first option, at index ix
            initial_ix_done=0
            while initial_ix_done==0:
                if ix==len(strlist):
                    initial_ix_done=1
                elif strlist[ix][0]=='-':
                    initial_ix_done=1
                else:
                    if self.verbose>2:
                         print('Incrementing ix')
                    ix=ix+1
                    
            # If there is an option, then ix is its index
            if ix<len(strlist):
                
                cmd_name=strlist[ix][1:]
                # If there was two dashes, one will be left so
                # remove it
                if cmd_name[0]=='-':
                    cmd_name=cmd_name[1:]
                if self.verbose>2:
                    print('Found option',cmd_name,'at index',ix)
                # Set ix_next to the next option, or to the end if
                # there is no next option
                ix_next=ix+1
                ix_next_done=0
                while ix_next_done==0:
                    if ix_next==len(strlist):
                        ix_next_done=1
                    elif len(strlist[ix_next])>0 and strlist[ix_next][0]=='-':
                        ix_next_done=1
                    else:
                        if self.verbose>2:
                            print('Incrementing ix_next')
                        ix_next=ix_next+1

                # List of 'acol' commands for option processing loop
                acol_list=['a','alias','assign','autocorr','c',
                           'calc','cat','commands','contours','convert-unit',
                           'convert_unit','create','d','D',
                           'delete-col','delete-rows','delete-rows-tol',
                           'delete_col','delete_rows','delete_rows_tol',
                           'deriv','deriv2',
                           'download','entry','f','filelist','find-row',
                           'find_row','fit','function','g','gen3-list',
                           'gen3_list','generic','get-conv','get-row',
                           'get-unit','get_conv','get_row','get_unit',
                           'h','help','i','I','index','insert','insert-full',
                           'insert_full','integ','internal','interp',
                           'interp-type','interp_type','l','license','list',
                           'max','min','N','nlines','o','output','P',
                           'preview','q',
                           'r','read','rename','run',
                           's','S','select','select-rows',
                           'select_rows','select-rows2','select_rows2',
                           'set-data','set_data','set-unit',
                           'set_unit','show-units','show_units','slice',
                           'sort','stats','sum','to-hist','to_hist',
                           'to-hist-2d' 'to_hist_2d',
                           'to_table3d','to-table','to_table','to-table3d',
                           'type','v','warranty']
                
                # Now process the option
                if cmd_name=='set':

                    if self.verbose>2:
                        print('Process set.')
                        
                    if ix_next-ix<3:
                        print('Not enough parameters for set option.')
                    else:
                        self.set_wrapper(o2scl_hdf,amp,strlist[ix+1:ix_next])
                        
                elif cmd_name=='get':
                    
                    if self.verbose>2:
                        print('Process get.')
                        
                    if ix_next-ix<2:
                        self.get('No parameter specified to get.')
                    else:
                        self.get_wrapper(o2scl_hdf,amp,strlist[ix+1:ix_next])

                elif cmd_name=='commands':
                    
                    if self.verbose>2:
                        print('Process commands.')
                        
                    self.gen(o2scl_hdf,amp,cmd_name,
                             strlist[ix+1:ix_next])

                    if (ix_next-ix)==2:
                        
                        curr_type=strlist[ix+1]
                        
                    else:

                        # Get current type
                        int_ptr=ctypes.POINTER(ctypes.c_int)
                        char_ptr=ctypes.POINTER(ctypes.c_char)
                        char_ptr_ptr=ctypes.POINTER(char_ptr)

                        # Set up wrapper for type function
                        type_fn=o2scl_hdf.o2scl_acol_get_type
                        type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]

                        # Get current type
                        it=ctypes.c_int(0)
                        type_ptr=char_ptr()
                        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
                        curr_type=b''
                        for i in range(0,it.value):
                            curr_type=curr_type+type_ptr[i]

                    print('O2graph commands for type '+
                          str(curr_type)+':\n')
                    strout=''
                    for line in base_list:
                        strout+=line[0]+' '
                    for line in extra_list:
                        if (curr_type==line[0] or
                            curr_type==force_bytes(line[0])):
                            strout+=line[1]+' '
                    str_list=textwrap.wrap(strout,79)
                    for i in range (0,len(str_list)):
                        print(str_list[i])
                            
                elif cmd_name=='yt-add-vol':

                    int_ptr=ctypes.POINTER(ctypes.c_int)
                    char_ptr=ctypes.POINTER(ctypes.c_char)
                    char_ptr_ptr=ctypes.POINTER(char_ptr)
                    double_ptr=ctypes.POINTER(ctypes.c_double)
                    double_ptr_ptr=ctypes.POINTER(double_ptr)
                    
                    # Set up wrapper for type function
                    type_fn=o2scl_hdf.o2scl_acol_get_type
                    type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]
                    
                    # Get current type
                    it=ctypes.c_int(0)
                    type_ptr=char_ptr()
                    type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                    
                    curr_type=b''
                    for i in range(0,it.value):
                        curr_type=curr_type+type_ptr[i]

                    if curr_type==b'tensor_grid':
                        self.check_backend()
                        import yt
                        from yt.visualization.volume_rendering.api \
                            import VolumeSource
                        from yt.visualization.volume_rendering.transfer_function_helper \
    import TransferFunctionHelper

                        # Set up wrapper for get function
                        get_fn=o2scl_hdf.o2scl_acol_get_tensor_grid3
                        get_fn.argtypes=[ctypes.c_void_p,int_ptr,int_ptr,
                                         int_ptr,double_ptr_ptr,
                                         double_ptr_ptr,double_ptr_ptr,
                                         double_ptr_ptr]
                        get_fn.restype=ctypes.c_int

                        # Call get function
                        nx=ctypes.c_int(0)
                        ny=ctypes.c_int(0)
                        nz=ctypes.c_int(0)
                        ret=ctypes.c_int(0)
                        gridx=double_ptr()
                        gridy=double_ptr()
                        gridz=double_ptr()
                        data=double_ptr()
                        ret=get_fn(amp,ctypes.byref(nx),ctypes.byref(ny),
                                   ctypes.byref(nz),ctypes.byref(gridx),
                                   ctypes.byref(gridy),ctypes.byref(gridz),
                                   ctypes.byref(data))

                        nx=nx.value
                        ny=ny.value
                        nz=nz.value
                        total_size=nx*ny*nz
                        maxval=data[0]
                        minval=data[0]
                        for ij in range(0,total_size):
                            if data[ij]>maxval:
                                maxval=data[ij]
                            if data[ij]<minval:
                                minval=data[ij]
                        drange=maxval-minval

                        if self.xset==False:
                            self.xlo=gridx[0]
                            self.xhi=gridx[nx-1]
                        if self.yset==False:
                            self.ylo=gridy[0]
                            self.yhi=gridy[ny-1]
                        if self.zset==False:
                            self.zlo=gridz[0]
                            self.zhi=gridz[nz-1]
                        
                        arr=numpy.ctypeslib.as_array(data,shape=(nx,ny,nz))
                        bbox=numpy.array([[0.0,1.0],[0.0,1.0],[0.0,1.0]])
                        ds=yt.load_uniform_grid(dict(density=arr),
                                                arr.shape,bbox=bbox)

                        vol=VolumeSource(ds,field='density')
                        vol.log_field=False

                        # Setup the transfer function
                        if True:
                            vol.set_transfer_function(self.yt_tf)
                            print(self.yt_tf)
                            # tf=yt.ColorTransferFunction((minval,maxval),
                            #                             grey_opacity=False)
                            # wid=0.012
                            # tf.add_gaussian(minval+drange*0.9,wid,
                            #                 [1.0,0.0,0.0,1.0])
                            # wid=0.01
                            # tf.add_gaussian(minval+drange*0.5,wid,
                            #                 [0.0,1.0,0.0,1.0])
                            # wid=0.012
                            # tf.add_gaussian(minval+drange*0.1,wid,
                            #                 [0.0,0.0,1.0,1.0])
                            # vol.set_transfer_function(tf)
                            # print(tf)
                        else:
                            tfh=TransferFunctionHelper(ds)
                            tfh.set_field('density')
                            tfh.set_log(False)
                            tfh.set_bounds()
                            tfh.build_transfer_function()
                            tfh.tf.add_layers(3)
                            #tfh.plot('tf.png')
                            vol.set_transfer_function(tfh.tf)
                            print(tfh.tf)
                        
                        if self.yt_created_scene==False:
                            self.yt_create_scene()

                        self.yt_scene.add_source(vol,keyname='vol1')
                            
                        if self.yt_created_camera==False:
                            self.yt_create_camera(ds)

                elif cmd_name=='yt-scatter':

                    int_ptr=ctypes.POINTER(ctypes.c_int)
                    char_ptr=ctypes.POINTER(ctypes.c_char)
                    char_ptr_ptr=ctypes.POINTER(char_ptr)
                    double_ptr=ctypes.POINTER(ctypes.c_double)
                    double_ptr_ptr=ctypes.POINTER(double_ptr)
                    
                    # Set up wrapper for type function
                    type_fn=o2scl_hdf.o2scl_acol_get_type
                    type_fn.argtypes=[ctypes.c_void_p,int_ptr,char_ptr_ptr]
                    
                    # Get current type
                    it=ctypes.c_int(0)
                    type_ptr=char_ptr()
                    type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                    
                    curr_type=b''
                    for i in range(0,it.value):
                        curr_type=curr_type+type_ptr[i]

                    if curr_type==b'table':
                        self.check_backend()
                        import yt
                        from yt.visualization.volume_rendering.api \
                            import PointSource
                        
                        get_fn=o2scl_hdf.o2scl_acol_get_column
                        get_fn.argtypes=[ctypes.c_void_p,ctypes.c_char_p,
                                         int_ptr,double_ptr_ptr]
                        get_fn.restype=ctypes.c_int
                        
                        colx=ctypes.c_char_p(force_bytes(strlist[ix+1]))
                        idx=ctypes.c_int(0)
                        ptrx=double_ptr()
                        get_ret=get_fn(amp,colx,ctypes.byref(idx),
                                       ctypes.byref(ptrx))
                        if get_ret!=0:
                            print('Failed to get column named "'+
                                  strlist[ix+1]+'".')
                            failed=True
                            
                        coly=ctypes.c_char_p(force_bytes(strlist[ix+2]))
                        idy=ctypes.c_int(0)
                        ptry=double_ptr()
                        get_ret=get_fn(amp,coly,ctypes.byref(idy),
                                       ctypes.byref(ptry))
                        if get_ret!=0:
                            print('Failed to get column named "'+
                                  strlist[ix+3]+'".')
                            failed=True

                        colz=ctypes.c_char_p(force_bytes(strlist[ix+2]))
                        idz=ctypes.c_int(0)
                        ptrz=double_ptr()
                        get_ret=get_fn(amp,colz,ctypes.byref(idz),
                                       ctypes.byref(ptrz))
                        if get_ret!=0:
                            print('Failed to get column named "'+
                                  strlist[ix+3]+'".')
                            failed=True

                        if self.xset==False:
                            self.xlo=ptrx[0]
                            self.xhi=ptrx[0]
                            for i in range(0,idx.value):
                                if ptrx[i]<self.xlo:
                                    self.xlo=ptrx[i]
                                if ptrx[i]>self.xhi:
                                    self.xhi=ptrx[i]
                        if self.yset==False:
                            self.ylo=ptry[0]
                            self.yhi=ptry[0]
                            for i in range(0,idy.value):
                                if ptry[i]<self.ylo:
                                    self.ylo=ptry[i]
                                if ptry[i]>self.yhi:
                                    self.yhi=ptry[i]
                        if self.zset==False:
                            self.zlo=ptrz[0]
                            self.zhi=ptrz[0]
                            for i in range(0,idz.value):
                                if ptrz[i]<self.zlo:
                                    self.zlo=ptrz[i]
                                if ptrz[i]>self.zhi:
                                    self.zhi=ptrz[i]
                        x_range=self.xhi-self.xlo
                        y_range=self.yhi-self.ylo
                        z_range=self.zhi-self.zlo

                        pts=[]
                        cols=[]
                        for i in range(0,idx.value):
                            pts.append([(ptrx[i]-self.xlo)/x_range,
                                        (ptry[i]-self.ylo)/y_range,
                                        (ptrz[i]-self.zlo)/z_range])
                            cols.append([1,1,1,1])
                        pts2=numpy.array(pts)
                        cols2=numpy.array(cols)

                        ps=PointSource(pts2,colors=cols2,radii=3)
                                       
                        if self.yt_created_scene==False:
                            self.yt_create_scene()

                        self.yt_scene.add_source(ps,keyname='o2graph_point')
                        
                        if self.yt_created_camera==False:
                            self.yt_create_camera(ps)
                            
                elif cmd_name=='yt-render':
                    
                    if self.xtitle!='':
                        yt_text_to_scene([0.5,-0.05,-0.05],
                                         self.xtitle,
                                         keyname='o2graph_x_axis')
                    if self.ytitle!='':
                        yt_text_to_scene([-0.05,0.5,-0.05],
                                         self.ytitle,
                                         keyname='o2graph_y_axis')
                    if self.ztitle!='':
                        yt_text_to_scene([-0.05,-0.05,0.5],
                                         self.ztitle,
                                         keyname='o2graph_z_axis')
                        
                    self.yt_scene.render()
                    self.yt_scene.save(strlist[ix+1],sigma_clip=1.0)

                elif cmd_name=='yt-tf':

                    if strlist[ix+1]=='new':
                        print('New transfer function')
                        print('min:',strlist[ix+2],'max:',strlist[ix+3])
                        self.yt_tf=yt.ColorTransferFunction((float(strlist[ix+2]),
                                                             float(strlist[ix+3])),
                                                            grey_opacity=False)
                    elif strlist[ix+1]=='gauss':
                        print('Add Gaussian')
                        print('loc:',strlist[ix+2],'wid:',strlist[ix+3])
                        print('r:',strlist[ix+4],'g:',strlist[ix+5])
                        print('b:',strlist[ix+6],'alpha:',strlist[ix+7])
                        self.yt_tf.add_gaussian(float(strlist[ix+2]),
                                                float(strlist[ix+3]),
                                                [float(strlist[ix+4]),
                                                 float(strlist[ix+5]),
                                                 float(strlist[ix+6]),
                                                 float(strlist[ix+7])])

                elif cmd_name=='help' or cmd_name=='h':
                    
                    if self.verbose>2:
                        print('Process help.')

                    curr_type=''
                    cmd=''

                    redirected=False
                    if sys.stdout.isatty()==False:
                        redirected=True
                    
                    str_line=''
                    if redirected:
                        for jj in range(0,78):
                            str_line+='-'
                    else:
                        str_line=str_line+chr(27)+'(0'
                        for jj in range(0,78):
                            str_line+='q'
                        str_line=str_line+chr(27)+'(B'
                        
                    # If only a command is specified
                    if (ix_next-ix)==2:

                        # Get current type
                        int_ptr=ctypes.POINTER(ctypes.c_int)
                        char_ptr=ctypes.POINTER(ctypes.c_char)
                        char_ptr_ptr=ctypes.POINTER(char_ptr)

                        # Set up wrapper for type function
                        type_fn=o2scl_hdf.o2scl_acol_get_type
                        type_fn.argtypes=[ctypes.c_void_p,int_ptr,
                                          char_ptr_ptr]

                        # Get current type
                        it=ctypes.c_int(0)
                        type_ptr=char_ptr()
                        type_fn(amp,ctypes.byref(it),ctypes.byref(type_ptr))
                
                        curr_type=b''
                        for i in range(0,it.value):
                            curr_type=curr_type+type_ptr[i]
                            
                        cmd=strlist[ix+1]

                    elif (ix_next-ix)==3:
                        # If both a type and command are specified
                        
                        curr_type=strlist[ix+1]
                        cmd=strlist[ix+2]

                    # See if we matched an o2graph command
                    match=False
                    
                    # Handle the case of an o2graph command from the
                    # base list
                    for line in base_list:
                        if cmd==line[0]:
                            match=True
                            print('Usage: '+cmd+' '+line[2]+'\n\n'+
                                  line[1]+'\n')
                            tempx_arr=line[3].split('\n')
                            for j in range(0,len(tempx_arr)):
                                #print('here.'+tempx_arr[j]+'.')
                                if len(tempx_arr[j])<79:
                                    print(tempx_arr[j])
                                else:
                                    str_list=textwrap.wrap(tempx_arr[j],79)
                                    for i in range (0,len(str_list)):
                                        print(str_list[i])
                                
                    # Handle the case of an o2graph command from the
                    # extra list
                    for line in extra_list:
                        if ((curr_type==line[0] or
                             curr_type==force_bytes(line[0])) and
                            cmd==line[1]):
                            match=True
                            print('Usage: '+cmd+' '+line[3]+'\n\n'+
                                  line[2]+'\n')
                            str_list=textwrap.wrap(line[4],79)
                            for i in range (0,len(str_list)):
                                print(str_list[i])

                    finished=False
                    if (cmd=='cmaps_list') and (ix_next-ix)==2:
                        print('Matplotlib colormaps:')
                        print(str_line)
                        for category, cmap_list in cmaps:
                            list2=''
                            for name in cmap_list:
                                list2+=name+' '
                            str_list=textwrap.wrap(category+': '+list2,79)
                            for i in range (0,len(str_list)):
                                print(str_list[i])
                            print(' ')
                        print('Remember that colormaps can all be',
                              'reversed by using a "_r" suffix.')
                        finished=True

                    if (cmd=='cmaps' or cmd=='cmap') and (ix_next-ix)==2:

                        if self.new_cmaps_defined==False:
                            self.new_cmaps()

                        print('Generating colormap summary figure.')
                        
                        # An internal implementation of
                        # https://matplotlib.org/3.1.0/gallery/
                        # color/colormap_reference.html
                        
                        self.left_margin=0.01
                        self.right_margin=0.01
                        self.top_margin=0.01
                        self.bottom_margin=0.01
                        gradient=numpy.linspace(0,1,256)
                        gradient=numpy.vstack((gradient,gradient))
                        
                        nrows=0
                        for category, cmap_list in cmaps:
                            for name in cmap_list:
                                nrows=nrows+1
                        for category, cmap_list in new_cmaps:
                            for name in cmap_list:
                                nrows=nrows+1
                        ncols=3
                        while nrows%ncols!=0:
                            nrows=nrows+1
                        nrows=int((nrows)/ncols)

                        # Manually create figure and axes 
                        fig_x=7.0
                        fig_y=0.95*(0.35+0.15+(nrows+(nrows-1)*0.1)*0.22)
                        (self.fig,self.axes)=plot.subplots(nrows=nrows,
                                                           ncols=ncols,
                                                           figsize=(fig_x,
                                                                    fig_y))
                        self.fig.subplots_adjust(top=1.0-0.35/fig_y,
                                                 bottom=0.15/fig_y,
                                                 left=0.01,right=0.99,
                                                 wspace=0.01)
                        plot.rc('text',usetex=True)
                        plot.rc('font',family='serif')

                        for i in range(0,nrows):
                            for j in range(0,ncols):
                                self.axes[i][j].set_axis_off()
                        
                        row_ctr=0
                        col_ctr=0
                        for category, cmap_list in cmaps:
                            for name in cmap_list:
                                name2=name.replace('_','\_')
                                ax=self.axes[row_ctr][col_ctr]
                                ax.imshow(gradient,aspect='auto',
                                                 cmap=plot.get_cmap(name))
                                r=patches.Rectangle((0.32,0.1),0.36,0.8,0,
                                                    fc=(1,1,1,0.7),lw=0,
                                                    fill=True,
                                                    transform=ax.transAxes)
                                ax.add_patch(r)
                                ax.text(0.5,0.45,name2,
                                                    va='center',ha='center',
                                                    fontsize=8,color=(0,0,0),
                                                    transform=ax.transAxes)
                                row_ctr=row_ctr+1
                                if row_ctr>=nrows:
                                    row_ctr=0
                                    col_ctr=col_ctr+1
                        for category, cmap_list in new_cmaps:
                            for name in cmap_list:
                                name2=name.replace('_','\_')
                                ax=self.axes[row_ctr][col_ctr]
                                ax.imshow(gradient,aspect='auto',
                                                 cmap=plot.get_cmap(name))
                                r=patches.Rectangle((0.32,0.1),0.36,0.8,0,
                                                    fc=(1,1,1,0.7),lw=0,
                                                    fill=True,
                                                    transform=ax.transAxes)
                                ax.add_patch(r)
                                ax.text(0.5,0.45,name2,
                                        va='center',ha='center',
                                        fontsize=8,color=(0,0,0),
                                        transform=ax.transAxes)
                                row_ctr=row_ctr+1
                                if row_ctr>=nrows:
                                    row_ctr=0
                                    col_ctr=col_ctr+1

                        ax=self.axes[0][0]
                        ax.text(1.5,1.7,
                                (r'$ \mathrm{O}_2\mathrm{sc'+
                                 'lpy~colormap~reference} $'),
                                ha='center',va='center',fontsize=16,
                                transform=ax.transAxes)
                        plot.savefig('o2graph_cmaps.png')
                        print('Created file o2graph_cmaps.png.')
                        print('Remember that colormaps can all be',
                              'reversed by using a "_r" suffix.')
                        import matplotlib
                        if (matplotlib.get_backend()!='Agg' and 
                            matplotlib.get_backend()!='agg'):
                            plot.show()
                        finished=True

                    if (cmd=='colors') and (ix_next-ix)==2:
                        from matplotlib import colors as mc

                        colors=dict(**mc.CSS4_COLORS)
                        by_hsv=sorted((tuple(mc.rgb_to_hsv(mc.to_rgba(color)[:3])),name)
                                        for name, color in colors.items())
                        sorted_names=[name for hsv, name in by_hsv]
                        n=len(sorted_names)
                        ncols=4
                        nrows=n//ncols
                        plot.rc('text',usetex=True)
                        plot.rc('font',family='serif')
                        self.fig,self.axes=plot.subplots(figsize=(8,6.4))
                        # Get height and width
                        X,Y=self.fig.get_dpi()*self.fig.get_size_inches()
                        h=Y/(nrows+1)
                        w=X/ncols

                        ax=self.axes
                        for i, name in enumerate(sorted_names):
                            row=i%nrows
                            col=i//nrows
                            y=Y-(row*h)-h
                            xi_line=w*(col+0.05)
                            xf_line=w*(col+0.25)
                            xi_text=w*(col+0.3)
                            ax.text(xi_text,y,name,fontsize=(h*0.6),
                                    ha='left',va='center')

                            ax.hlines(y+h*0.1,xi_line,xf_line,
                                      color=colors[name],linewidth=(h*0.8))

                            ax.set_xlim(0,X)
                            ax.set_ylim(0,Y)
                            ax.set_axis_off()
                            
                            self.fig.subplots_adjust(left=0,right=1,
                                                     top=1,bottom=0,
                                                     hspace=0,wspace=0)
                        plot.savefig('o2graph_colors.png')
                        print('Created file o2graph_colors.png.')
                        import matplotlib
                        if (matplotlib.get_backend()!='Agg' and 
                            matplotlib.get_backend()!='agg'):
                            plot.show()
                        finished=True
                        
                    if len(strlist)>ix+1 and strlist[ix+1]=='colors2':
                        from matplotlib import colors as mc

                        colors=dict(**mc.CSS4_COLORS,**mc.XKCD_COLORS)
                        by_hsv=sorted((tuple(mc.rgb_to_hsv(mc.to_rgba(color)[:3])),name)
                                        for name, color in colors.items())
                        sorted_names=[(hsv, name) for hsv, name in by_hsv]
                        selected=[]
                        if (ix_next-ix)==3 and strlist[ix+2]=='greys':
                            for i in range(0,len(sorted_names)):
                                if (sorted_names[i][0][1]<0.2):
                                    selected.append((sorted_names[i][0][0],
                                                     sorted_names[i][0][1],
                                                     sorted_names[i][0][2],
                                                     sorted_names[i][1]))
                        elif (ix_next-ix)==3 and strlist[ix+2]=='reds':
                            for i in range(0,len(sorted_names)):
                                if (sorted_names[i][0][0]>0.0 and
                                    sorted_names[i][0][0]<0.05 and
                                    sorted_names[i][0][1]>0.2):
                                    selected.append((sorted_names[i][0][0],
                                                     sorted_names[i][0][1],
                                                     sorted_names[i][0][2],
                                                     sorted_names[i][1]))
                        elif (ix_next-ix)==3 and strlist[ix+2]=='oranges':
                            for i in range(0,len(sorted_names)):
                                if (sorted_names[i][0][0]>0.05 and
                                    sorted_names[i][0][0]<0.105 and
                                    sorted_names[i][0][1]>0.2):
                                    selected.append((sorted_names[i][0][0],
                                                     sorted_names[i][0][1],
                                                     sorted_names[i][0][2],
                                                     sorted_names[i][1]))
                        elif (ix_next-ix)==3 and strlist[ix+2]=='yellows':
                            for i in range(0,len(sorted_names)):
                                if (sorted_names[i][0][0]>0.105 and
                                    sorted_names[i][0][0]<0.17 and
                                    sorted_names[i][0][1]>0.2):
                                    selected.append((sorted_names[i][0][0],
                                                     sorted_names[i][0][1],
                                                     sorted_names[i][0][2],
                                                     sorted_names[i][1]))
                        elif (ix_next-ix)==3 and strlist[ix+2]=='greens':
                            for i in range(0,len(sorted_names)):
                                if (sorted_names[i][0][0]>0.17 and
                                    sorted_names[i][0][0]<0.25 and
                                    sorted_names[i][0][1]>0.2):
                                    selected.append((sorted_names[i][0][0],
                                                     sorted_names[i][0][1],
                                                     sorted_names[i][0][2],
                                                     sorted_names[i][1]))
                        elif (ix_next-ix)==3 and strlist[ix+2]=='blues':
                            for i in range(0,len(sorted_names)):
                                if (sorted_names[i][0][0]>0.0 and
                                    sorted_names[i][0][0]<0.05 and
                                    sorted_names[i][0][1]>0.2):
                                    selected.append((sorted_names[i][0][0],
                                                     sorted_names[i][0][1],
                                                     sorted_names[i][0][2],
                                                     sorted_names[i][1]))
                        elif (ix_next-ix)==3 and strlist[ix+2]=='purples':
                            for i in range(0,len(sorted_names)):
                                if (sorted_names[i][0][0]>0.0 and
                                    sorted_names[i][0][0]<0.05 and
                                    sorted_names[i][0][1]>0.2):
                                    selected.append((sorted_names[i][0][0],
                                                     sorted_names[i][0][1],
                                                     sorted_names[i][0][2],
                                                     sorted_names[i][1]))
                        elif (ix_next-ix)==3 and strlist[ix+2]=='pinks':
                            for i in range(0,len(sorted_names)):
                                if (sorted_names[i][0][0]>0.0 and
                                    sorted_names[i][0][0]<0.05 and
                                    sorted_names[i][0][1]>0.2):
                                    selected.append((sorted_names[i][0][0],
                                                     sorted_names[i][0][1],
                                                     sorted_names[i][0][2],
                                                     sorted_names[i][1]))
                        else:
                            print('Hue          Saturation',
                                  '  Value        name')
                            for i in range(0,len(sorted_names)):
                                print('%7.6e %7.6e %7.6e %s' %
                                      (sorted_names[i][0][0],
                                       sorted_names[i][0][1],
                                       sorted_names[i][0][2],
                                       sorted_names[i][1]))
                                
                        if len(selected)>0:
                            n=len(selected)
                            ncols=4
                            nrows=n//ncols
                            plot.rc('text',usetex=True)
                            plot.rc('font',family='serif')
                            self.fig,self.axes=plot.subplots(figsize=(8,6.4))
                            # Get height and width
                            X,Y=self.fig.get_dpi()*self.fig.get_size_inches()
                            h=Y/(nrows+1)
                            w=X/ncols
    
                            ax=self.axes
                            for i in range(0,n):
                                row=i%nrows
                                col=i//nrows
                                y=Y-(row*h)-h
                                xi_line=w*(col+0.05)
                                xf_line=w*(col+0.25)
                                xi_text=w*(col+0.3)
                                ax.text(xi_text,y,
                                        selected[i][3]+str(selected[i][0]),
                                        fontsize=(h*0.2),
                                        ha='left',va='center')
    
                                ax.hlines(y+h*0.1,xi_line,xf_line,
                                          color=selected[i][3],
                                          linewidth=(h*0.8))
    
                                ax.set_xlim(0,X)
                                ax.set_ylim(0,Y)
                                ax.set_axis_off()
                                
                                self.fig.subplots_adjust(left=0,right=1,
                                                         top=1,bottom=0,
                                                         hspace=0,wspace=0)
                            plot.savefig('o2graph_colors2.png')
                            print('Created file o2graph_colors2.png.')
                            import matplotlib
                            if (matplotlib.get_backend()!='Agg' and 
                                matplotlib.get_backend()!='agg'):
                                plot.show()
                            
                        finished=True
                        
                    if (cmd=='color-list') and (ix_next-ix)==2:
                        from matplotlib import colors as mcolors
                        print('Matplotlib colors:')
                        print(str_line)
                        base_dict=dict(mcolors.BASE_COLORS)
                        css4_dict=dict(**mcolors.CSS4_COLORS)
                        print(len(base_dict),'base colors:')
                        outs=''
                        ctr=0
                        for col in base_dict:
                            outs=outs+(col+' '+str(base_dict[col])).ljust(20)
                            if ctr%4==3:
                                outs=outs+'\n'
                            ctr=ctr+1
                        print(outs)
                        print(len(css4_dict),'CSS4 colors:')
                        outs=''
                        ctr=0
                        for col in css4_dict:
                            if ctr%3==0:
                                outs=outs+(col+' '+
                                           str(css4_dict[col])).ljust(26)
                            elif ctr%3==1:
                                outs=outs+(col+' '+
                                           str(css4_dict[col])).ljust(28)
                            else:
                                outs=outs+(col+' '+
                                           str(css4_dict[col])).ljust(26)
                                outs=outs+'\n'
                            ctr=ctr+1
                        print(outs)
                        print(' ')
                        outs=('O2graph also supports the (r,g,b) format '+
                              'the HTML format, and the XKCD colors. '+
                              'For (r,g,b) colors, '+
                              'the r, g, and b numbers should be from '+
                              '0.0 to 1.0. The HTML format is #RRGGBB '+
                              'where RR, GG, and BB are two-digit '+
                              'hexadecimal values.')
                        str_list=textwrap.wrap(outs,79)
                        for i in range (0,len(str_list)):
                            print(str_list[i])
                        finished=True
                        
                    if (cmd=='xkcd-color-list') and (ix_next-ix)==2:
                        from matplotlib import colors as mcolors
                        xkcd_dict=dict(**mcolors.XKCD_COLORS)
                        print('XKCD colors:')
                        print(str_line)
                        # These are commented out for now because
                        # o2graph has a hard time with spaces in
                        # color names
                        print(len(xkcd_dict),'XKCD colors:')
                        outs=''
                        ctr=0
                        for col in xkcd_dict:
                            if ctr%2==0:
                                outs=outs+(col+' '+
                                           str(xkcd_dict[col])).ljust(40)
                            else:
                                outs=outs+(col+' '+
                                           str(xkcd_dict[col])).ljust(39)
                                outs=outs+'\n'
                            ctr=ctr+1
                        print(outs)
                        finished=True

                    if (cmd=='marker-list') and (ix_next-ix)==2:
                        print('Matplotlib markers supported by O2graph:')
                        print(str_line)
                        outs='. point'.ljust(20)
                        outs=outs+', pixel'.ljust(20)
                        outs=outs+'o circle'.ljust(20)
                        outs=outs+'v triangle_down'.ljust(20)+'\n'
                        outs=outs+'^ triangle_up'.ljust(20)
                        outs=outs+'< triangle_left'.ljust(20)
                        outs=outs+'> triangle_right'.ljust(20)
                        outs=outs+'1 tri_down'.ljust(20)+'\n'
                        outs=outs+'2 tri_up'.ljust(20)
                        outs=outs+'3 tri_left'.ljust(20)
                        outs=outs+'4 tri_right'.ljust(20)
                        outs=outs+'8 octagon'.ljust(20)+'\n'
                        outs=outs+'s square'.ljust(20)
                        outs=outs+'p pentagon'.ljust(20)
                        outs=outs+'P plus (filled)'.ljust(20)
                        outs=outs+'* star'.ljust(20)+'\n'
                        outs=outs+'h hexagon1'.ljust(20)
                        outs=outs+'H hexagon2'.ljust(20)
                        outs=outs+'+ plus'.ljust(20)
                        outs=outs+'x x'.ljust(20)+'\n'
                        outs=outs+'X x (filled)'.ljust(20)
                        outs=outs+'D diamond'.ljust(20)
                        outs=outs+'d thin_diamond'.ljust(20)
                        outs=outs+'| vline'.ljust(20)+'\n'
                        outs=outs+'_ hline'.ljust(20)
                        outs=outs+'$...$ mathtext string'.ljust(20)
                        print(outs)
                        finished=True

                    if (cmd=='markers') and (ix_next-ix)==2:
                        mlist=[['.',"'.'",'point'],
                               [',',"','",'pixel'],
                               ['o',"'o'",'circle'],
                               ['v',"'v'",'down triangle'],
                               ['^',"'^'",'up triangle'],
                               ['<',"'<'",'left triangle'],
                               ['>',"'>'",'right triangle'],
                               ['1',"'1'",'down tri'],
                               ['2',"'2'",'up tri'],
                               ['3',"'3'",'left tri'],
                               ['4',"'4'",'right tri'],
                               ['8',"'8'",'octagon'],
                               ['s',"'s'",'square'],
                               ['p',"'p'",'pentagon'],
                               ['P',"'P'",'plus (filled)'],
                               ['*',"'*'",'star'],
                               ['h',"'h'",'hexagon 1'],
                               ['H',"'H'",'hexagon 2'],
                               ['+',"'+'",'plus'],
                               ['x',"'x'",'x'],
                               ['X',"'X'",'filled x'],
                               ['D',"'D'",'diamond'],
                               ['d',"'d'",'thin diamond'],
                               ['|',"'|'",'vertical line'],
                               ['_',"'_'",'horizontal line'],
                               [0,"0",'left tick'],
                               [1,"1",'right tick'],
                               [2,"2",'up tick'],
                               [3,"3",'down tick'],
                               [4,"4",'left caret'],
                               [5,"5",'right caret'],
                               [6,"6",'up caret'],
                               [7,"7",'down caret'],
                               [8,"8",'left shifted caret'],
                               [9,"9",'right shifted caret'],
                               [10,"10",'up shifted caret'],
                               [11,"11",'down shifted caret'],
                               ['$x^2$',"\$x^2\$",'math example']]
                        nmark=len(mlist)
                        ncols=2
                        nrows=(nmark+(nmark%2))/ncols
                        self.xlo=0
                        self.xhi=1
                        self.xset=True
                        self.fig_dict=('left_margin=0.01,top_margin=0.01,'+
                                       'right_margin=0.01,'+
                                       'bottom_margin=0.01,'+
                                       'fontsize=10,ticks_in=False,'+
                                       'rt_ticks=False')
                        self.canvas()
                        self.canvas_flag=True
                        self.axes.set_axis_off()
                        row_ctr=0
                        col_ctr=0
                        for entry in mlist:
                            if row_ctr>2:
                                plot.rc('text',usetex=False)
                                self.point(str((col_ctr+0.1)/(ncols)),
                                           str((nrows-row_ctr)/(nrows+1)),
                                           marker=entry[0],color='black',
                                           markersize=10)
                                self.text(str((col_ctr+0.25)/(ncols)),
                                          str((nrows-row_ctr)/(nrows+1)),
                                          entry[1],family='monospace',
                                          va='center',ha='center')
                                plot.rc('text',usetex=True)
                                self.text(str((col_ctr+0.37)/(ncols)),
                                          str((nrows-row_ctr)/(nrows+1)),
                                          entry[2].replace('_','\_'),
                                          va='center',ha='left')
                            row_ctr=row_ctr+1
                            if row_ctr>=nrows:
                                row_ctr=0
                                col_ctr=col_ctr+1
                        plot.savefig('o2graph_markers.png')
                        import matplotlib
                        if (matplotlib.get_backend()!='Agg' and 
                            matplotlib.get_backend()!='agg'):
                            plot.show()
                        finished=True
                        
                    # Handle the case of an acol command 
                    if match==False and finished==False:
                        self.gen(o2scl_hdf,amp,cmd_name,
                                 strlist[ix+1:ix_next])

                    # If the user specified 'help set', then print
                    # the o2graph parameter documentation
                    if (cmd=='set' or cmd=='get') and (ix_next-ix)==2:
                        self.print_param_docs()

                    # If no arguments were given, then give a list of
                    # o2graph commands in addition to acol commands
                    if (ix_next-ix)==1:
                        print(str_line)
                        print('\nO2graph command-line options:\n')
                        for line in base_list:
                            strt='  -'+line[0]
                            while len(strt)<16:
                                strt=strt+' '
                            strt+=line[1]
                            print(strt)
                        print('\n'+str_line)
                        print('O2graph type-specific commands:\n')
                        extra_types.sort()
                        for typename in extra_types:
                            strt=typename+': '
                            first=True
                            for line in extra_list:
                                if line[0]==typename:
                                    if first==True:
                                        strt+=line[1]
                                        first=False
                                    else:
                                        strt+=', '+line[1]
                            str_list=textwrap.wrap(strt,77)
                            for i in range (0,len(str_list)):
                                if i==0:
                                    print(str_list[i])
                                else:
                                    print(' ',str_list[i])
                        print('\n'+str_line)
                        print('Additional o2graph help topics:',
                              'markers, cmaps, colors')

                elif cmd_name=='version':
                    
                    print('o2graph: A data table plotting and',
                          'processing program for O2scl.')
                    print(' Version '+version+'.')

                elif cmd_name=='plot':
                    
                    if self.verbose>2:
                        print('Process plot.')

                    self.plot(o2scl_hdf,amp,strlist[ix+1:ix_next])

                elif cmd_name=='rplot':
                    
                    if self.verbose>2:
                        print('Process rplot.')

                    self.rplot(o2scl_hdf,amp,strlist[ix+1:ix_next])

                elif cmd_name=='scatter':
                    
                    if self.verbose>2:
                        print('Process scatter.')

                    self.scatter(o2scl_hdf,amp,strlist[ix+1:ix_next])

                elif cmd_name=='histplot':
                    
                    if self.verbose>2:
                        print('Process histplot.')

                    self.histplot(o2scl_hdf,amp,strlist[ix+1:ix_next])

                elif cmd_name=='errorbar':
                    
                    if self.verbose>2:
                        print('Process errorbar.')

                    self.errorbar(o2scl_hdf,amp,strlist[ix+1:ix_next])

                elif cmd_name=='hist2dplot':
                    
                    if self.verbose>2:
                        print('Process hist2dplot.')
                        
                    self.hist2dplot(o2scl_hdf,amp,strlist[ix+1:ix_next])
                            
                elif cmd_name=='den-plot':
                    
                    if self.verbose>2:
                        print('Process den-plot.')

                    self.den_plot(o2scl_hdf,amp,strlist[ix+1:ix_next])
                
                elif cmd_name=='plot1':
                    
                    if self.verbose>2:
                        print('Process plot1.')
                        
                    self.plot1(o2scl_hdf,amp,strlist[ix+1:ix_next])
                            
                elif cmd_name=='plotv':
                    
                    if self.verbose>2:
                        print('Process plotv.')
                        
                    if ix_next-ix<2:
                        print('Not enough parameters for plotv option.')
                    else:
                        self.plotv(o2scl_hdf,amp,strlist[ix+1:ix_next])
                                                    
                elif cmd_name=='text':
                    
                    if self.verbose>2:
                        print('Process text.')
                        
                    if ix_next-ix<4:
                        print('Not enough parameters for text option.')
                    elif ix_next-ix<5:
                        self.text(strlist[ix+1],strlist[ix+2],strlist[ix+3])
                    else:
                        self.text(strlist[ix+1],strlist[ix+2],strlist[ix+3],
                                  **string_to_dict(strlist[ix+4]))
                        
                elif cmd_name=='ttext':
                    
                    if self.verbose>2:
                        print('Process ttext.')
                        
                    if ix_next-ix<4:
                        print('Not enough parameters for ttext option.')
                    elif ix_next-ix<5:
                        self.ttext(strlist[ix+1],strlist[ix+2],strlist[ix+3])
                    else:
                        self.ttext(strlist[ix+1],strlist[ix+2],strlist[ix+3],
                                   **string_to_dict(strlist[ix+4]))
                        
                elif cmd_name=='xlimits':
                    
                    if self.verbose>2:
                        print('Process xlimits.')
                        
                    if ix_next-ix<3:
                        print('Not enough parameters for xlimits option.')
                    else:
                        self.xlimits(float(strlist[ix+1]),float(strlist[ix+2]))
                        
                elif cmd_name=='ylimits':
                    
                    if self.verbose>2:
                        print('Process ylimits.')
                        
                    if ix_next-ix<3:
                        print('Not enough parameters for ylimits option.')
                    else:
                        self.ylimits(float(strlist[ix+1]),float(strlist[ix+2]))
                        
                elif cmd_name=='save':
                    if self.verbose>2:
                        
                        print('Process save.')
                    if ix_next-ix<2:
                        print('Not enough parameters for save option.')
                    else:
                        plot.savefig(strlist[ix+1])
                        
                elif cmd_name=='subplots':
                    
                    if self.verbose>2:
                        print('Process subplots.')
                        
                    if ix_next-ix<2:
                        print('Not enough parameters for subplots option.')
                    elif ix_next-ix<3:
                        self.subplots(int(strlist[ix+1]))
                    elif ix_next-ix<4:
                        self.subplots(int(strlist[ix+1]),int(strlist[ix+2]))
                    else:
                        self.subplots(int(strlist[ix+1]),int(strlist[ix+2]),
                                      **string_to_dict(strlist[ix+3]))
                        
                elif cmd_name=='selsub':
                    
                    if self.verbose>2:
                        print('Process selsub.')
                        
                    if ix_next-ix<2:
                        print('Not enough parameters for selsub option.')
                    elif ix_next-ix<3:
                        self.selsub(int(strlist[ix+1]))
                    else:
                        self.selsub(int(strlist[ix+1]),int(strlist[ix+2]))
                        
                elif cmd_name=='subadj':
                    
                    if self.verbose>2:
                        print('Process subadj.')

                    if ix_next-ix<2:
                        print('Not enough parameters for subadj option.')
                    else:
                        plot.subplots_adjust(**string_to_dict(strlist[ix+1]))
                        
                elif cmd_name=='xtitle':
                    
                    if self.verbose>2:
                        print('Process xtitle.')

                    if ix_next-ix<1:
                        print('Not enough parameters for xtitle option.')
                    else:
                        self.xtitle(strlist[ix+1])
                        
                elif cmd_name=='ytitle':
                    
                    if self.verbose>2:
                        print('Process ytitle.')

                    if ix_next-ix<1:
                        print('Not enough parameters for ytitle option.')
                    else:
                        self.ytitle(strlist[ix+1])
                        
                elif cmd_name=='line':
                    
                    if self.verbose>2:
                        print('Process line.')
                        
                    if ix_next-ix<5:
                        print('Not enough parameters for line option.')
                    elif ix_next-ix<6:
                        self.line(strlist[ix+1],strlist[ix+2],
                                  strlist[ix+3],strlist[ix+4])
                    else:
                        self.line(strlist[ix+1],strlist[ix+2],
                                  strlist[ix+3],strlist[ix+4],
                                  **string_to_dict(strlist[ix+5]))
                        
                elif cmd_name=='textbox':
                    
                    if self.verbose>2:
                        print('Process textbox.')
                        
                    if ix_next-ix<5:
                        print('Not enough parameters for textbox option.')
                    elif ix_next-ix<6:
                        self.textbox(strlist[ix+1],strlist[ix+2],
                                  strlist[ix+3],strlist[ix+4])
                    else:
                        self.textbox(strlist[ix+1],strlist[ix+2],
                                     strlist[ix+3],strlist[ix+4],
                                     **string_to_dict(strlist[ix+5]))
                        
                elif cmd_name=='arrow':
                    
                    if self.verbose>2:
                        print('Process arrow.')
                        
                    if ix_next-ix<6:
                        print('Not enough parameters for arrow option.')
                    elif ix_next-ix<7:
                        self.arrow(strlist[ix+1],strlist[ix+2],
                                   strlist[ix+3],strlist[ix+4],
                                   strlist[ix+5])
                    else:
                        self.arrow(strlist[ix+1],strlist[ix+2],
                                   strlist[ix+3],strlist[ix+4],
                                   strlist[ix+5],
                                   **string_to_dict(strlist[ix+6]))
                        
                elif cmd_name=='point':
                    
                    if self.verbose>2:
                        print('Process point.')
                        
                    if ix_next-ix<3:
                        print('Not enough parameters for point option.')
                    elif ix_next-ix<4:
                        self.point(strlist[ix+1],strlist[ix+2])
                    else:
                        self.point(strlist[ix+1],strlist[ix+2],
                                   **string_to_dict(strlist[ix+3]))
                        
                elif cmd_name=='python':
                    
                    if self.verbose>2:
                        print('Process python.')

                    print("The o2graph_plotter() object is named 'self'.")
                    print("Use 'import o2sclpy' and 'help(o2sclpy)' +"
                          "for more help on o2sclpy "+
                          "classes and functions.")
                    code.interact(local=locals())
                    
                elif cmd_name=='eval':
                    
                    if self.verbose>2:
                        print('Process eval.')

                    eval(strlist[ix+1],None,locals())
                    
                elif cmd_name=='rect':
                    
                    if self.verbose>2:
                        print('Process rect.')
                        
                    if ix_next-ix<6:
                        print('Not enough parameters for rect option.')
                    elif ix_next-ix<7:
                        self.rect(strlist[ix+1],strlist[ix+2],
                                  strlist[ix+3],strlist[ix+4],
                                  strlist[ix+5])
                    else:
                        self.rect(strlist[ix+1],strlist[ix+2],
                                  strlist[ix+3],strlist[ix+4],
                                  strlist[ix+5],
                                  **string_to_dict(strlist[ix+6]))
                        
                elif cmd_name=='move-labels':
                    if self.verbose>2:
                        print('Process move-labels.')
                    self.move_labels()
                elif cmd_name=='show':
                    if self.verbose>2:
                        print('Process show.')
                    self.show()
                elif cmd_name=='move-labels':
                    if self.verbose>2:
                        print('Process move-labels.')
                    self.move_labels()
                elif cmd_name=='canvas':
                    if self.verbose>2:
                        print('Process canvas.')
                    self.canvas()
                elif cmd_name=='clf':
                    if self.verbose>2:
                        print('Process clf.')
                    plot.clf()
                    self.canvas_flag=False
                elif cmd_name=='backend':
                    if self.verbose>2:
                        print('Process backend in __init__.py.')
                elif cmd_name=='new-cmaps':
                    if self.verbose>2:
                        print('Process reds2.')
                    self.new_cmaps()
                else:
                    if self.verbose>2:
                        print('Process acol command '+cmd_name+'.')
                    self.gen(o2scl_hdf,amp,cmd_name,strlist[ix+1:ix_next])
                    
                # Increment to the next option
                ix=ix_next
                
            if self.verbose>2:
                print('Going to next.')
                
        # End of function parse_string_list()
        return
    
